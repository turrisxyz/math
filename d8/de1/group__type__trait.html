<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: Type Traits</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../$standoxy.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">4.3.2</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d8/de1/group__type__trait.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Type Traits</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The type traits in Stan math are a mix of custom traits for detecting value and container types of <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrices, standard vectors, standard complex numbers, and backports of C++17 traits. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dfd/structstan_1_1is__constant_3_01_t_00_01require__all__kernel__expressions__and__none__scalar__t_3_01_t_01_4_01_4.html">stan::is_constant&lt; T, require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbb/structstan_1_1math_1_1ad__promotable.html">stan::math::ad_promotable&lt; From, To, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d56/structstan_1_1math_1_1conjunction.html">stan::math::conjunction&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">stan::math::disjunction&lt; Conds &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dda/structstan_1_1math_1_1include__summand.html">stan::math::include_summand&lt; propto, T, T_pack &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dc3/structstan_1_1math_1_1include__summand_3_01propto_00_01_t_01_4.html">stan::math::include_summand&lt; propto, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d9a/structstan_1_1math_1_1index__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#de/d9a/structstan_1_1math_1_1index__type">stan::math::index_type&lt; T, typename &gt;</a></td></tr>
<tr class="separator:de/d9a/structstan_1_1math_1_1index__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d8e/structstan_1_1is__arena__matrix.html">stan::is_arena_matrix&lt; T, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dff/structstan_1_1is__autodiff.html">stan::is_autodiff&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a var or fvar.  <a href="../../d1/dff/structstan_1_1is__autodiff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de1/structstan_1_1internal_1_1is__complex__impl.html">stan::internal::is_complex_impl&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a member constant <code>value</code> which is equal to <code>true</code> if <code>T</code> is an instance of <code>std::complex</code> and <code>false</code> otherwise.  <a href="../../d5/de1/structstan_1_1internal_1_1is__complex__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d57/structstan_1_1is__complex.html">stan::is_complex&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>T</code> is an arithmetic type (that is, an instance of <code>std::complex</code>) or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="../../d0/d57/structstan_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc7/structstan_1_1is__vt__complex.html">stan::is_vt_complex&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <code><a class="el" href="../../da/dce/namespacestan.html#dd/d27/structstan_1_1value__type">value_type</a></code> of the type <code>T</code> is of type <code>std::complex</code> or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="../../de/dc7/structstan_1_1is__vt__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d93/structstan_1_1is__vt__not__complex.html">stan::is_vt_not_complex&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <code><a class="el" href="../../da/dce/namespacestan.html#dd/d27/structstan_1_1value__type">value_type</a></code> of the type <code>T</code> is not of type <code>std::complex</code> or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="../../da/d93/structstan_1_1is__vt__not__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d70/structstan_1_1is__constant.html">stan::is_constant&lt; T, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d39/structstan_1_1is__constant_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html">stan::is_constant&lt; T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d41/structstan_1_1is__double__or__int.html">stan::is_double_or_int&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a double or integer.  <a href="../../dd/d41/structstan_1_1is__double__or__int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7d/structstan_1_1is__eigen.html">stan::is_eigen&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type derives from <code>EigenBase</code>  <a href="../../dc/d7d/structstan_1_1is__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d22/structstan_1_1is__eigen__array.html">stan::is_eigen_array&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is derived from <code>Eigen::ArrayBase</code>  <a href="../../dc/d22/structstan_1_1is__eigen__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d7c/structstan_1_1is__eigen__contiguous__map.html">stan::is_eigen_contiguous_map&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is an <code>Eigen::Map</code> with contiguous stride.  <a href="../../d7/d7c/structstan_1_1is__eigen__contiguous__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbf/structstan_1_1is__eigen__dense__base.html">stan::is_eigen_dense_base&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::DenseBase.  <a href="../../da/dbf/structstan_1_1is__eigen__dense__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d6f/structstan_1_1is__eigen__matrix__dynamic.html">stan::is_eigen_matrix_dynamic&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::MatrixBase and has columns and rows not equal to 1.  <a href="../../db/d6f/structstan_1_1is__eigen__matrix__dynamic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d06/structstan_1_1is__eigen__sparse__base.html">stan::is_eigen_sparse_base&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::SparseMatrixBase.  <a href="../../d5/d06/structstan_1_1is__eigen__sparse__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df3/structstan_1_1is__fvar.html">stan::is_fvar&lt; T, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/ddf/structstan_1_1is__matrix.html">stan::is_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is derived from <code>Eigen::EigenBase</code> or is a <code>var_value</code> whose <code><a class="el" href="../../da/dce/namespacestan.html#dd/d27/structstan_1_1value__type">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="../../de/ddf/structstan_1_1is__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/structstan_1_1is__rev__matrix.html">stan::is_rev_matrix&lt; T, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dd5/structstan_1_1is__rev__col__vector.html">stan::is_rev_col_vector&lt; T, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd0/structstan_1_1is__rev__row__vector.html">stan::is_rev_row_vector&lt; T, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d4d/structstan_1_1is__rev__vector.html">stan::is_rev_vector&lt; T, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8f/structstan_1_1is__stan__scalar.html">stan::is_stan_scalar&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a var, fvar, or arithmetic.  <a href="../../da/d8f/structstan_1_1is__stan__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d9d/structstan_1_1is__var.html">stan::is_var&lt; T, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d6d/structstan_1_1is__var__dense__dynamic.html">stan::is_var_dense_dynamic&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="../../da/dce/namespacestan.html#dd/d27/structstan_1_1value__type">value_type</a></code> is derived from <code>Eigen::EigenBase</code> and has dynamic rows and columns.  <a href="../../db/d6d/structstan_1_1is__var__dense__dynamic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dbb/structstan_1_1is__var__eigen.html">stan::is_var_eigen&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="../../da/dce/namespacestan.html#dd/d27/structstan_1_1value__type">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="../../dc/dbb/structstan_1_1is__var__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d25/structstan_1_1is__var__matrix.html">stan::is_var_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="../../da/dce/namespacestan.html#dd/d27/structstan_1_1value__type">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="../../d6/d25/structstan_1_1is__var__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d2f/structstan_1_1is__var__col__vector.html">stan::is_var_col_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="../../da/dce/namespacestan.html#dd/d27/structstan_1_1value__type">value_type</a></code> is derived from <code>Eigen::EigenBase</code>.  <a href="../../d9/d2f/structstan_1_1is__var__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d2c/structstan_1_1is__var__row__vector.html">stan::is_var_row_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="../../da/dce/namespacestan.html#dd/d27/structstan_1_1value__type">value_type</a></code> is derived from <code>Eigen::EigenBase</code>.  <a href="../../dc/d2c/structstan_1_1is__var__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dbf/structstan_1_1is__var__vector.html">stan::is_var_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="../../da/dce/namespacestan.html#dd/d27/structstan_1_1value__type">value_type</a></code> is derived from <code>Eigen::EigenBase</code>.  <a href="../../d9/dbf/structstan_1_1is__var__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d38/structstan_1_1is__any__var__matrix.html">stan::is_any_var_matrix&lt; Types &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any types in a parameter pack are a <code>var_value</code> whose <code><a class="el" href="../../da/dce/namespacestan.html#dd/d27/structstan_1_1value__type">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="../../d7/d38/structstan_1_1is__any__var__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d4f/structstan_1_1is__var__or__arithmetic__type.html">stan::is_var_or_arithmetic_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d64/structstan_1_1is__vari.html">stan::is_vari&lt; T, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/db6/structstan_1_1is__std__vector.html">stan::is_std_vector&lt; T, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d1b/structstan_1_1internal_1_1is__eigen__col__vector__impl.html">stan::internal::is_eigen_col_vector_impl&lt; T, bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d04/structstan_1_1internal_1_1is__eigen__col__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_eigen_col_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dbc/structstan_1_1internal_1_1is__eigen__row__vector__impl.html">stan::internal::is_eigen_row_vector_impl&lt; T, bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd7/structstan_1_1internal_1_1is__eigen__row__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_eigen_row_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d21/structstan_1_1internal_1_1is__col__vector__impl.html">stan::internal::is_col_vector_impl&lt; T, bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5c/structstan_1_1internal_1_1is__col__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_col_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d83/structstan_1_1internal_1_1is__row__vector__impl.html">stan::internal::is_row_vector_impl&lt; T, bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d54/structstan_1_1internal_1_1is__row__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_row_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d37/structstan_1_1is__eigen__col__vector.html">stan::is_eigen_col_vector&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dff/structstan_1_1is__col__vector.html">stan::is_col_vector&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc1/structstan_1_1is__eigen__row__vector.html">stan::is_eigen_row_vector&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d90/structstan_1_1is__row__vector.html">stan::is_row_vector&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d3b/structstan_1_1is__eigen__vector.html">stan::is_eigen_vector&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d82/structstan_1_1is__vector.html">stan::is_vector&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d0c/structstan_1_1internal_1_1is__std__vector__impl.html">stan::internal::is_std_vector_impl&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df7/structstan_1_1internal_1_1is__std__vector__impl_3_01std_1_1vector_3_01_args_8_8_8_01_4_01_4.html">stan::internal::is_std_vector_impl&lt; std::vector&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d23/structstan_1_1is__std__vector_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__std__vector__28c6aea3001284899b87957f6f2ae7d6.html">stan::is_std_vector&lt; T, std::enable_if_t&lt; internal::is_std_vector_impl&lt; std::decay_t&lt; T &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d45/structstan_1_1is__vector__like.html">stan::is_vector_like&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d0b/structstan_1_1is__arena__matrix_3_01_t_00_01require__t_3_01internal_1_1is__arena__matrix__impl_382c328ab88094a24a9cfff97c4ae9a76.html">stan::is_arena_matrix&lt; T, require_t&lt; internal::is_arena_matrix_impl&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df4/structstan_1_1is__rev__matrix_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3_01_t1ddd3dfbec50668d893a6befdfb0b45a.html">stan::is_rev_matrix&lt; T, require_all_t&lt; is_var&lt; scalar_type_t&lt; T &gt; &gt;, math::disjunction&lt; math::conjunction&lt; is_var&lt; T &gt;, is_eigen&lt; value_type_t&lt; T &gt; &gt; &gt;, is_eigen&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd8/structstan_1_1is__rev__col__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_30dc403fb8542198c3091e4e6e1e54ba5.html">stan::is_rev_col_vector&lt; T, require_all_t&lt; is_var&lt; scalar_type_t&lt; T &gt; &gt;, math::disjunction&lt; is_eigen_col_vector&lt; T &gt;, is_eigen_col_vector&lt; value_type_t&lt; T &gt; &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/df9/structstan_1_1is__rev__row__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3f675c2ac2e6bea3e3104996f22b12a50.html">stan::is_rev_row_vector&lt; T, require_all_t&lt; is_var&lt; scalar_type_t&lt; T &gt; &gt;, math::disjunction&lt; is_eigen_row_vector&lt; T &gt;, is_eigen_row_vector&lt; value_type_t&lt; T &gt; &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d51/structstan_1_1is__rev__vector_3_01_t_00_01require__any__t_3_01is__rev__col__vector_3_01_t_01_4_0ee983b7fdcdd0eeacbfc45ed12837bd6.html">stan::is_rev_vector&lt; T, require_any_t&lt; is_rev_col_vector&lt; T &gt;, is_rev_row_vector&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d9d/structstan_1_1is__var_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__var__impl_3_01std_1_14fc46eebc2d7d167cda3892bd7b10182.html">stan::is_var&lt; T, std::enable_if_t&lt; internal::is_var_impl&lt; std::decay_t&lt; T &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/da1/structstan_1_1is__vari_3_01_t_00_01require__t_3_01internal_1_1is__vari__impl_3_01std_1_1decay__t_3_01_t_01_4_01_4_01_4_01_4.html">stan::is_vari&lt; T, require_t&lt; internal::is_vari_impl&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad1046e42476333dc3c08c35bfe420302"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:gad1046e42476333dc3c08c35bfe420302"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gad1046e42476333dc3c08c35bfe420302">stan::bool_constant</a> = std::integral_constant&lt; bool, B &gt;</td></tr>
<tr class="separator:gad1046e42476333dc3c08c35bfe420302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9fdfc37e81ef7ab9e1d46ebe9fd6ae9"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gab9fdfc37e81ef7ab9e1d46ebe9fd6ae9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gab9fdfc37e81ef7ab9e1d46ebe9fd6ae9">stan::contains_fvar</a> = <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; <a class="el" href="../../d4/df3/structstan_1_1is__fvar.html">is_fvar</a>&lt; <a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &gt;... &gt;</td></tr>
<tr class="separator:gab9fdfc37e81ef7ab9e1d46ebe9fd6ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gaaa1b1eb615a4b1b30b46ef33ace88cdf">stan::contains_std_vector</a> = <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; <a class="el" href="../../d0/db6/structstan_1_1is__std__vector.html">is_std_vector</a>&lt; Ts &gt;... &gt;</td></tr>
<tr class="separator:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga880b82cbb2b83ccaba2426e73996b8bd">stan::is_constant_all</a> = <a class="el" href="../../da/d56/structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="../../d5/d70/structstan_1_1is__constant.html">is_constant</a>&lt; T &gt;... &gt;</td></tr>
<tr class="separator:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad118aaa390bacd754a1a06c9518739ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad118aaa390bacd754a1a06c9518739ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gad118aaa390bacd754a1a06c9518739ce">stan::is_dense_dynamic</a> = <a class="el" href="../../d4/d8e/structstan_1_1internal_1_1is__dense__dynamic__impl.html">internal::is_dense_dynamic_impl</a>&lt; std::decay_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:gad118aaa390bacd754a1a06c9518739ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::DenseBase and has dynamic rows and columns or is a <code>var_value&lt;&gt;</code> whose inner type satisfies the conditions above.  <a href="../../d8/de1/group__type__trait.html#gad118aaa390bacd754a1a06c9518739ce">More...</a><br /></td></tr>
<tr class="separator:gad118aaa390bacd754a1a06c9518739ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e24dfe00dd09775b290fc2221b2739d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3e24dfe00dd09775b290fc2221b2739d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga3e24dfe00dd09775b290fc2221b2739d">stan::is_eigen_matrix_or_array</a> = <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; <a class="el" href="../../d2/d4e/structstan_1_1is__eigen__matrix__base.html">is_eigen_matrix_base</a>&lt; T &gt;, <a class="el" href="../../dc/d22/structstan_1_1is__eigen__array.html">is_eigen_array</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga3e24dfe00dd09775b290fc2221b2739d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is derived from <code>Eigen::MatrixBase</code> or <code>Eigen::ArrayBase</code>  <a href="../../d8/de1/group__type__trait.html#ga3e24dfe00dd09775b290fc2221b2739d">More...</a><br /></td></tr>
<tr class="separator:ga3e24dfe00dd09775b290fc2221b2739d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f64859b99515465810d1dbf2885a8e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9f64859b99515465810d1dbf2885a8e7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga9f64859b99515465810d1dbf2885a8e7">stan::is_eigen_dense_dynamic</a> = <a class="el" href="../../d3/d5e/structstan_1_1internal_1_1is__eigen__matrix__dynamic__impl.html">stan::internal::is_eigen_matrix_dynamic_impl</a>&lt; std::decay_t&lt; T &gt;, <a class="el" href="../../da/dbf/structstan_1_1is__eigen__dense__base.html">stan::is_eigen_dense_base</a>&lt; std::decay_t&lt; T &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:ga9f64859b99515465810d1dbf2885a8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::DenseBase and has dynamic rows and columns.  <a href="../../d8/de1/group__type__trait.html#ga9f64859b99515465810d1dbf2885a8e7">More...</a><br /></td></tr>
<tr class="separator:ga9f64859b99515465810d1dbf2885a8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17bf5c3cd4cc2794e47ea0e0609bbf9f"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:ga17bf5c3cd4cc2794e47ea0e0609bbf9f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga17bf5c3cd4cc2794e47ea0e0609bbf9f">stan::is_plain_type</a> = std::is_same&lt; std::decay_t&lt; S &gt;, <a class="el" href="../../da/dce/namespacestan.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; S &gt; &gt;</td></tr>
<tr class="separator:ga17bf5c3cd4cc2794e47ea0e0609bbf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga597c18eee233b7aa27f52a2068e5b881"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga597c18eee233b7aa27f52a2068e5b881"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga597c18eee233b7aa27f52a2068e5b881">stan::is_stan_scalar_or_eigen</a> = <a class="el" href="../../d8/de1/group__type__trait.html#gad1046e42476333dc3c08c35bfe420302">bool_constant</a>&lt; <a class="el" href="../../da/d8f/structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt; std::decay_t&lt; T &gt; &gt;::value||<a class="el" href="../../dc/d7d/structstan_1_1is__eigen.html">is_eigen</a>&lt; std::decay_t&lt; T &gt; &gt;::value &gt;</td></tr>
<tr class="separator:ga597c18eee233b7aa27f52a2068e5b881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f2252ae22390725feb09d9ea11b7896"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0f2252ae22390725feb09d9ea11b7896"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga0f2252ae22390725feb09d9ea11b7896">stan::is_string_convertible</a> = std::is_convertible&lt; T, std::string &gt;</td></tr>
<tr class="memdesc:ga0f2252ae22390725feb09d9ea11b7896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces whether type is convertible to string.  <a href="../../d8/de1/group__type__trait.html#ga0f2252ae22390725feb09d9ea11b7896">More...</a><br /></td></tr>
<tr class="separator:ga0f2252ae22390725feb09d9ea11b7896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga9d36a4d6158f96c2321b4fbf55243ca8">stan::is_var_or_arithmetic</a> = <a class="el" href="../../da/d56/structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="../../dd/d4f/structstan_1_1is__var__or__arithmetic__type.html">is_var_or_arithmetic_type</a>&lt; T &gt;... &gt;</td></tr>
<tr class="separator:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga1310fb459dbad72fa5594b6d1eaad959">stan::partials_type_t</a> = typename <a class="el" href="../../da/dce/namespacestan.html#d0/db7/structstan_1_1partials__type">partials_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546483131616701876a9f1307f5a413d"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga546483131616701876a9f1307f5a413d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga546483131616701876a9f1307f5a413d">stan::promote_args_t</a> = typename boost::math::tools::promote_args&lt; Args... &gt;::type</td></tr>
<tr class="separator:ga546483131616701876a9f1307f5a413d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">stan::real_return_t</a> = typename <a class="el" href="../../da/dce/namespacestan.html#d0/dc1/structstan_1_1real__return">real_return</a>&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:gac9d3fe14d5102916bf0b5b05712c833e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the real return type.  <a href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">More...</a><br /></td></tr>
<tr class="separator:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf21bb3c3ca46c48bb58c33a5260b74c7"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaf21bb3c3ca46c48bb58c33a5260b74c7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">stan::complex_return_t</a> = std::complex&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt; &gt;</td></tr>
<tr class="memdesc:gaf21bb3c3ca46c48bb58c33a5260b74c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>std::complex</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">More...</a><br /></td></tr>
<tr class="separator:gaf21bb3c3ca46c48bb58c33a5260b74c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876ae6b470c58e692b4a4273a32f7ea3"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga876ae6b470c58e692b4a4273a32f7ea3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga876ae6b470c58e692b4a4273a32f7ea3">stan::std_vector_return_t</a> = std::vector&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt; &gt;</td></tr>
<tr class="memdesc:ga876ae6b470c58e692b4a4273a32f7ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>std::vector</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#ga876ae6b470c58e692b4a4273a32f7ea3">More...</a><br /></td></tr>
<tr class="separator:ga876ae6b470c58e692b4a4273a32f7ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gab3412a1caaad7f8eef55a9ee2a0d3921">stan::matrix_return_t</a> = Eigen::Matrix&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;, -1, -1 &gt;</td></tr>
<tr class="memdesc:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, -1&gt;</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#gab3412a1caaad7f8eef55a9ee2a0d3921">More...</a><br /></td></tr>
<tr class="separator:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b070b6ae219eccccf07b44243307b8b"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga1b070b6ae219eccccf07b44243307b8b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga1b070b6ae219eccccf07b44243307b8b">stan::vector_return_t</a> = Eigen::Matrix&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;, -1, 1 &gt;</td></tr>
<tr class="memdesc:ga1b070b6ae219eccccf07b44243307b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, 1&gt;</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#ga1b070b6ae219eccccf07b44243307b8b">More...</a><br /></td></tr>
<tr class="separator:ga1b070b6ae219eccccf07b44243307b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga2fa4e21b37c08e6abce2919ac4c2cd57">stan::row_vector_return_t</a> = Eigen::Matrix&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;, 1, -1 &gt;</td></tr>
<tr class="memdesc:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , 1, -1&gt;</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#ga2fa4e21b37c08e6abce2919ac4c2cd57">More...</a><br /></td></tr>
<tr class="separator:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gace9d2d5da99a3e14fcadd7bf0f6cffee">stan::scalar_lub_t</a> = typename <a class="el" href="../../da/dce/namespacestan.html#d5/d1d/structstan_1_1scalar__lub">scalar_lub</a>&lt; T1, T2 &gt;::type</td></tr>
<tr class="memdesc:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type for the least upper bound of the specified template parameters in Stan's assignment ordering.  <a href="../../d8/de1/group__type__trait.html#gace9d2d5da99a3e14fcadd7bf0f6cffee">More...</a><br /></td></tr>
<tr class="separator:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a> = typename <a class="el" href="../../da/dce/namespacestan.html#d8/d68/structstan_1_1return__type">return_type</a>&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:gacbaff683cd2683209e6855e2c7aaeffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type for the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">More...</a><br /></td></tr>
<tr class="separator:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57121ded0440567e8dfb0d80b1290922"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga57121ded0440567e8dfb0d80b1290922"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">stan::value_type_t</a> = typename <a class="el" href="../../da/dce/namespacestan.html#dd/d27/structstan_1_1value__type">value_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ga57121ded0440567e8dfb0d80b1290922"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae29786dab3b9274d3f1d08f6904854eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/dcd/classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01fvar_3_01_dx_01_4_01_4.html#afce03dc72ef9b35eb9045d3c7b060fd5">T_return_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gae29786dab3b9274d3f1d08f6904854eb">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, fvar&lt; Dx &gt; &gt;::build</a> (Dx value)</td></tr>
<tr class="separator:gae29786dab3b9274d3f1d08f6904854eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gad2a93cdd718b76d4994d0f7c6c05fbba">stan::get</a> (const T &amp;x, size_t n)</td></tr>
<tr class="separator:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431bd201f09a215cccb16cda10a1e840"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga431bd201f09a215cccb16cda10a1e840"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga431bd201f09a215cccb16cda10a1e840">stan::get</a> (const std::vector&lt; T &gt; &amp;x, size_t n)</td></tr>
<tr class="separator:ga431bd201f09a215cccb16cda10a1e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98afb6ae5281b82b30caa793e205f6ae"><td class="memTemplParams" colspan="2">template&lt;typename T , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga98afb6ae5281b82b30caa793e205f6ae"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga98afb6ae5281b82b30caa793e205f6ae">stan::math::size</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ga98afb6ae5281b82b30caa793e205f6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size (number of the elements) of a <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> or <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt;<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;T&gt;&gt;</code>.  <a href="../../d8/de1/group__type__trait.html#ga98afb6ae5281b82b30caa793e205f6ae">More...</a><br /></td></tr>
<tr class="separator:ga98afb6ae5281b82b30caa793e205f6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a1e2f6c725ab45a9a0d5335ae9b0c1"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT , require_stan_scalar_t&lt; ScalarT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab9a1e2f6c725ab45a9a0d5335ae9b0c1"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gab9a1e2f6c725ab45a9a0d5335ae9b0c1">stan::math::size_mvt</a> (const ScalarT &amp;)</td></tr>
<tr class="separator:gab9a1e2f6c725ab45a9a0d5335ae9b0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga9b28065e82cdcee1c320a7120cb8a83d">stan::math::internal::broadcast_array&lt; T &gt;::operator=</a> (const Y &amp;m)</td></tr>
<tr class="separator:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc34a86c0bb1a9853b36aa4c952a4dc"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga0bc34a86c0bb1a9853b36aa4c952a4dc">stan::math::internal::empty_broadcast_array&lt; T, S, Enable &gt;::operator[]</a> (int)</td></tr>
<tr class="separator:ga0bc34a86c0bb1a9853b36aa4c952a4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390dff20f30679c8e57ca2c3efe6d766"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ga390dff20f30679c8e57ca2c3efe6d766"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga390dff20f30679c8e57ca2c3efe6d766">stan::math::internal::empty_broadcast_array&lt; T, S, Enable &gt;::operator=</a> (const Y &amp;)</td></tr>
<tr class="separator:ga390dff20f30679c8e57ca2c3efe6d766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06037332423259c9f5fa57c9b72ad3b"><td class="memItemLeft" align="right" valign="top">ViewElt &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gaf06037332423259c9f5fa57c9b72ad3b">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator[]</a> (int)</td></tr>
<tr class="separator:gaf06037332423259c9f5fa57c9b72ad3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a702889907a3c12704df6c514fcc07"><td class="memItemLeft" align="right" valign="top">ViewElt &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga80a702889907a3c12704df6c514fcc07">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator()</a> (int)</td></tr>
<tr class="separator:ga80a702889907a3c12704df6c514fcc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga501ec44e68851a8396f5f693e35a2e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga501ec44e68851a8396f5f693e35a2e69">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator=</a> (const <a class="el" href="../../d2/d19/classstan_1_1math_1_1internal_1_1empty__broadcast__array_3_01_view_elt_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#ae60f68cce56bd8855479f31c9d37ca50">T_arg</a> &amp;)</td></tr>
<tr class="separator:ga501ec44e68851a8396f5f693e35a2e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d157dabee552a681aa5e4406b86474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga84d157dabee552a681aa5e4406b86474">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator+=</a> (<a class="el" href="../../d2/d19/classstan_1_1math_1_1internal_1_1empty__broadcast__array_3_01_view_elt_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#ae60f68cce56bd8855479f31c9d37ca50">T_arg</a>)</td></tr>
<tr class="separator:ga84d157dabee552a681aa5e4406b86474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50070330d69c12c87811fcaf4e643803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga50070330d69c12c87811fcaf4e643803">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator-=</a> (<a class="el" href="../../d2/d19/classstan_1_1math_1_1internal_1_1empty__broadcast__array_3_01_view_elt_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#ae60f68cce56bd8855479f31c9d37ca50">T_arg</a>)</td></tr>
<tr class="separator:ga50070330d69c12c87811fcaf4e643803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd58c5861f0ee94465a97f78b2a00f0"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga8fd58c5861f0ee94465a97f78b2a00f0">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::row</a> (int)</td></tr>
<tr class="separator:ga8fd58c5861f0ee94465a97f78b2a00f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354e6529ea257ab6475be87e7c217ce9"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga354e6529ea257ab6475be87e7c217ce9">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::col</a> (int)</td></tr>
<tr class="separator:ga354e6529ea257ab6475be87e7c217ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52df2941f0acddad6251d218d9d62668"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga52df2941f0acddad6251d218d9d62668">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, T_return_type &gt;::build</a> (double value) const noexcept</td></tr>
<tr class="separator:ga52df2941f0acddad6251d218d9d62668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T_actual&gt;,                                          std::decay_t&lt;T_desired&gt;&gt;::value                             &amp;&amp; !is_eigen&lt;T_desired&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="memTemplItemLeft" align="right" valign="top">T_actual &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga0af4c158839e8c4c401e0f7e78bb4dc6">stan::math::forward_as</a> (T_actual &amp;&amp;a)</td></tr>
<tr class="separator:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;              !std::is_same&lt;std::decay&lt;T_actual&gt;, std::decay&lt;T_desired&gt;&gt;::value              &amp;&amp; (!is_eigen&lt;T_desired&gt;::value || !is_eigen&lt;T_actual&gt;::value)&gt;&gt; </td></tr>
<tr class="memitem:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memTemplItemLeft" align="right" valign="top">T_desired&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga6cc77bba018fff06dd1f0f0f2d79e5b9">stan::math::forward_as</a> (const T_actual &amp;a)</td></tr>
<tr class="separator:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385d807274aa40985a59c273d49cf9cd"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , require_eigen_t&lt; T_desired &gt; *  = nullptr, std::enable_if_t&lt; std::is_same&lt; value_type_t&lt; T_actual &gt;, value_type_t&lt; T_desired &gt;&gt;::value &amp;&amp;is_eigen&lt; T_desired &gt;::value &amp;&amp;is_eigen&lt; T_actual &gt;::value &amp;&amp;internal::eigen_static_size_match(T_desired::RowsAtCompileTime, std::decay_t&lt; T_actual &gt;::RowsAtCompileTime) &amp;&amp;internal::eigen_static_size_match(T_desired::ColsAtCompileTime, std::decay_t&lt; T_actual &gt;::ColsAtCompileTime)&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga385d807274aa40985a59c273d49cf9cd"><td class="memTemplItemLeft" align="right" valign="top">T_actual &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga385d807274aa40985a59c273d49cf9cd">stan::math::forward_as</a> (T_actual &amp;&amp;a)</td></tr>
<tr class="separator:ga385d807274aa40985a59c273d49cf9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd89dca2a48f398e759d882af2e62ddd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gacd89dca2a48f398e759d882af2e62ddd">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, var &gt;::build</a> (double value)</td></tr>
<tr class="separator:gacd89dca2a48f398e759d882af2e62ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="de/d9a/structstan_1_1math_1_1index__type" id="de/d9a/structstan_1_1math_1_1index__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#de/d9a/structstan_1_1math_1_1index__type">&#9670;&nbsp;</a></span>stan::math::index_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::math::index_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad1046e42476333dc3c08c35bfe420302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1046e42476333dc3c08c35bfe420302">&#9670;&nbsp;</a></span>bool_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gad1046e42476333dc3c08c35bfe420302">stan::bool_constant</a> = typedef std::integral_constant&lt;bool, B&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for structs used for wraps a static constant of bool. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>On true, inherits std::true_type, false is std::false_type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d6/dfd/bool__constant_8hpp_source.html#l00012">12</a> of file <a class="el" href="../../d6/dfd/bool__constant_8hpp_source.html">bool_constant.hpp</a>.</p>

</div>
</div>
<a id="gaf21bb3c3ca46c48bb58c33a5260b74c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf21bb3c3ca46c48bb58c33a5260b74c7">&#9670;&nbsp;</a></span>complex_return_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">stan::complex_return_t</a> = typedef std::complex&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt;Ts...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>std::complex</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/dce/namespacestan.html#d0/dc1/structstan_1_1real__return" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00057">57</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="gab9fdfc37e81ef7ab9e1d46ebe9fd6ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9fdfc37e81ef7ab9e1d46ebe9fd6ae9">&#9670;&nbsp;</a></span>contains_fvar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gab9fdfc37e81ef7ab9e1d46ebe9fd6ae9">stan::contains_fvar</a> = typedef <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt;<a class="el" href="../../d4/df3/structstan_1_1is__fvar.html">is_fvar</a>&lt;<a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt;T&gt; &gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extends std::true_type when instantiated with at least 1 template parameter that is a fvar. Extends std::false_type otherwise. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Types to test </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d10/contains__fvar_8hpp_source.html#l00017">17</a> of file <a class="el" href="../../da/d10/contains__fvar_8hpp_source.html">contains_fvar.hpp</a>.</p>

</div>
</div>
<a id="gaaa1b1eb615a4b1b30b46ef33ace88cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa1b1eb615a4b1b30b46ef33ace88cdf">&#9670;&nbsp;</a></span>contains_std_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gaaa1b1eb615a4b1b30b46ef33ace88cdf">stan::contains_std_vector</a> = typedef <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt;<a class="el" href="../../d0/db6/structstan_1_1is__std__vector.html">is_std_vector</a>&lt;Ts&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if any types are std vectors. </p>

<p class="definition">Definition at line <a class="el" href="../../de/dc9/contains__std__vector_8hpp_source.html#l00014">14</a> of file <a class="el" href="../../de/dc9/contains__std__vector_8hpp_source.html">contains_std_vector.hpp</a>.</p>

</div>
</div>
<a id="ga880b82cbb2b83ccaba2426e73996b8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga880b82cbb2b83ccaba2426e73996b8bd">&#9670;&nbsp;</a></span>is_constant_all</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga880b82cbb2b83ccaba2426e73996b8bd">stan::is_constant_all</a> = typedef <a class="el" href="../../da/d56/structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt;<a class="el" href="../../d5/d70/structstan_1_1is__constant.html">is_constant</a>&lt;T&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Metaprogram defining an enum <code>value</code> which is <code>true</code> if all of the type parameters are constant (i.e., primitive types) and <code>false</code> otherwise. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d53/prim_2meta_2is__constant_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../da/d53/prim_2meta_2is__constant_8hpp_source.html">is_constant.hpp</a>.</p>

</div>
</div>
<a id="gad118aaa390bacd754a1a06c9518739ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad118aaa390bacd754a1a06c9518739ce">&#9670;&nbsp;</a></span>is_dense_dynamic</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gad118aaa390bacd754a1a06c9518739ce">stan::is_dense_dynamic</a> = typedef <a class="el" href="../../d4/d8e/structstan_1_1internal_1_1is__dense__dynamic__impl.html">internal::is_dense_dynamic_impl</a>&lt;std::decay_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether type T is derived from Eigen::DenseBase and has dynamic rows and columns or is a <code>var_value&lt;&gt;</code> whose inner type satisfies the conditions above. </p>
<p>If true this will have a static member function named value with a type of true, else value is false. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to check </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/is__dense__dynamic_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../d0/dab/is__dense__dynamic_8hpp_source.html">is_dense_dynamic.hpp</a>.</p>

</div>
</div>
<a id="ga9f64859b99515465810d1dbf2885a8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f64859b99515465810d1dbf2885a8e7">&#9670;&nbsp;</a></span>is_eigen_dense_dynamic</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga9f64859b99515465810d1dbf2885a8e7">stan::is_eigen_dense_dynamic</a> = typedef <a class="el" href="../../d3/d5e/structstan_1_1internal_1_1is__eigen__matrix__dynamic__impl.html">stan::internal::is_eigen_matrix_dynamic_impl</a>&lt; std::decay_t&lt;T&gt;, <a class="el" href="../../da/dbf/structstan_1_1is__eigen__dense__base.html">stan::is_eigen_dense_base</a>&lt;std::decay_t&lt;T&gt; &gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether type T is derived from Eigen::DenseBase and has dynamic rows and columns. </p>
<p>If true this will have a static member function named value with a type of true, else value is false. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to check </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/da8/is__eigen__dense__dynamic_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../d7/da8/is__eigen__dense__dynamic_8hpp_source.html">is_eigen_dense_dynamic.hpp</a>.</p>

</div>
</div>
<a id="ga3e24dfe00dd09775b290fc2221b2739d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e24dfe00dd09775b290fc2221b2739d">&#9670;&nbsp;</a></span>is_eigen_matrix_or_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga3e24dfe00dd09775b290fc2221b2739d">stan::is_eigen_matrix_or_array</a> = typedef <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt;<a class="el" href="../../d2/d4e/structstan_1_1is__eigen__matrix__base.html">is_eigen_matrix_base</a>&lt;T&gt;, <a class="el" href="../../dc/d22/structstan_1_1is__eigen__array.html">is_eigen_array</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a type is derived from <code>Eigen::MatrixBase</code> or <code>Eigen::ArrayBase</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to check. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d8/dd8/is__eigen_8hpp_source.html#l00069">69</a> of file <a class="el" href="../../d8/dd8/is__eigen_8hpp_source.html">is_eigen.hpp</a>.</p>

</div>
</div>
<a id="ga17bf5c3cd4cc2794e47ea0e0609bbf9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17bf5c3cd4cc2794e47ea0e0609bbf9f">&#9670;&nbsp;</a></span>is_plain_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga17bf5c3cd4cc2794e47ea0e0609bbf9f">stan::is_plain_type</a> = typedef std::is_same&lt;std::decay_t&lt;S&gt;, <a class="el" href="../../da/dce/namespacestan.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt;S&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether the template type <code>T</code> is an assignable type. This is used to detect whether a type is an <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix expression. </p>

<p class="definition">Definition at line <a class="el" href="../../d6/dcd/is__plain__type_8hpp_source.html#l00014">14</a> of file <a class="el" href="../../d6/dcd/is__plain__type_8hpp_source.html">is_plain_type.hpp</a>.</p>

</div>
</div>
<a id="ga597c18eee233b7aa27f52a2068e5b881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga597c18eee233b7aa27f52a2068e5b881">&#9670;&nbsp;</a></span>is_stan_scalar_or_eigen</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga597c18eee233b7aa27f52a2068e5b881">stan::is_stan_scalar_or_eigen</a> = typedef <a class="el" href="../../d8/de1/group__type__trait.html#gad1046e42476333dc3c08c35bfe420302">bool_constant</a>&lt;<a class="el" href="../../da/d8f/structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt;std::decay_t&lt;T&gt; &gt;::value || <a class="el" href="../../dc/d7d/structstan_1_1is__eigen.html">is_eigen</a>&lt;std::decay_t&lt;T&gt; &gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extends std::true_type if all the provided types are either a Stan Scalar type or a type inheriting from <code>EigenBase</code>. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d5c/is__stan__scalar__or__eigen_8hpp_source.html#l00022">22</a> of file <a class="el" href="../../da/d5c/is__stan__scalar__or__eigen_8hpp_source.html">is_stan_scalar_or_eigen.hpp</a>.</p>

</div>
</div>
<a id="ga0f2252ae22390725feb09d9ea11b7896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f2252ae22390725feb09d9ea11b7896">&#9670;&nbsp;</a></span>is_string_convertible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga0f2252ae22390725feb09d9ea11b7896">stan::is_string_convertible</a> = typedef std::is_convertible&lt;T, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduces whether type is convertible to string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to check </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d4f/is__string__convertible_8hpp_source.html#l00016">16</a> of file <a class="el" href="../../dc/d4f/is__string__convertible_8hpp_source.html">is_string_convertible.hpp</a>.</p>

</div>
</div>
<a id="ga9d36a4d6158f96c2321b4fbf55243ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d36a4d6158f96c2321b4fbf55243ca8">&#9670;&nbsp;</a></span>is_var_or_arithmetic</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga9d36a4d6158f96c2321b4fbf55243ca8">stan::is_var_or_arithmetic</a> = typedef <a class="el" href="../../da/d56/structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt;<a class="el" href="../../dd/d4f/structstan_1_1is__var__or__arithmetic__type.html">is_var_or_arithmetic_type</a>&lt;T&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extends std::true_type if all the provided types are either var or an arithmetic type, extends std::false_type otherwise. </p>

<p class="definition">Definition at line <a class="el" href="../../d7/dfe/is__var__or__arithmetic_8hpp_source.html#l00030">30</a> of file <a class="el" href="../../d7/dfe/is__var__or__arithmetic_8hpp_source.html">is_var_or_arithmetic.hpp</a>.</p>

</div>
</div>
<a id="gab3412a1caaad7f8eef55a9ee2a0d3921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3412a1caaad7f8eef55a9ee2a0d3921">&#9670;&nbsp;</a></span>matrix_return_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gab3412a1caaad7f8eef55a9ee2a0d3921">stan::matrix_return_t</a> = typedef Eigen::Matrix&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt;Ts...&gt;, -1, -1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, -1&gt;</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/dce/namespacestan.html#d0/dc1/structstan_1_1real__return" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00080">80</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="ga1310fb459dbad72fa5594b6d1eaad959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1310fb459dbad72fa5594b6d1eaad959">&#9670;&nbsp;</a></span>partials_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga1310fb459dbad72fa5594b6d1eaad959">stan::partials_type_t</a> = typedef typename <a class="el" href="../../da/dce/namespacestan.html#d0/db7/structstan_1_1partials__type">partials_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper alias for accessing the partial type. </p>

<p class="definition">Definition at line <a class="el" href="../../dd/d43/prim_2meta_2partials__type_8hpp_source.html#l00020">20</a> of file <a class="el" href="../../dd/d43/prim_2meta_2partials__type_8hpp_source.html">partials_type.hpp</a>.</p>

</div>
</div>
<a id="ga546483131616701876a9f1307f5a413d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga546483131616701876a9f1307f5a413d">&#9670;&nbsp;</a></span>promote_args_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga546483131616701876a9f1307f5a413d">stan::promote_args_t</a> = typedef typename boost::math::tools::promote_args&lt;Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience alias for boost tools promote_args </p>

<p class="definition">Definition at line <a class="el" href="../../de/d54/promote__args_8hpp_source.html#l00012">12</a> of file <a class="el" href="../../de/d54/promote__args_8hpp_source.html">promote_args.hpp</a>.</p>

</div>
</div>
<a id="gac9d3fe14d5102916bf0b5b05712c833e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9d3fe14d5102916bf0b5b05712c833e">&#9670;&nbsp;</a></span>real_return_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">stan::real_return_t</a> = typedef typename <a class="el" href="../../da/dce/namespacestan.html#d0/dc1/structstan_1_1real__return">real_return</a>&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the real return type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/dce/namespacestan.html#d0/dc1/structstan_1_1real__return" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00046">46</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="gacbaff683cd2683209e6855e2c7aaeffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbaff683cd2683209e6855e2c7aaeffe">&#9670;&nbsp;</a></span>return_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a> = typedef typename <a class="el" href="../../da/dce/namespacestan.html#d8/d68/structstan_1_1return__type">return_type</a>&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type for the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/dce/namespacestan.html#d8/d68/structstan_1_1return__type" title="Template metaprogram to calculate the base scalar return type resulting from promoting all the scalar...">return_type</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00206">206</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="ga2fa4e21b37c08e6abce2919ac4c2cd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fa4e21b37c08e6abce2919ac4c2cd57">&#9670;&nbsp;</a></span>row_vector_return_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga2fa4e21b37c08e6abce2919ac4c2cd57">stan::row_vector_return_t</a> = typedef Eigen::Matrix&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt;Ts...&gt;, 1, -1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , 1, -1&gt;</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/dce/namespacestan.html#d0/dc1/structstan_1_1real__return" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00104">104</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="gace9d2d5da99a3e14fcadd7bf0f6cffee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace9d2d5da99a3e14fcadd7bf0f6cffee">&#9670;&nbsp;</a></span>scalar_lub_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gace9d2d5da99a3e14fcadd7bf0f6cffee">stan::scalar_lub_t</a> = typedef typename <a class="el" href="../../da/dce/namespacestan.html#d5/d1d/structstan_1_1scalar__lub">scalar_lub</a>&lt;T1, T2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type for the least upper bound of the specified template parameters in Stan's assignment ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T1</td><td>first type </td></tr>
    <tr><td class="paramname">T2</td><td>second type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/dce/namespacestan.html#d5/d1d/structstan_1_1scalar__lub" title="Defines a member type named type that is the least scalar type to which both template parameter scala...">scalar_lub</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00147">147</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="ga876ae6b470c58e692b4a4273a32f7ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga876ae6b470c58e692b4a4273a32f7ea3">&#9670;&nbsp;</a></span>std_vector_return_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga876ae6b470c58e692b4a4273a32f7ea3">stan::std_vector_return_t</a> = typedef std::vector&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt;Ts...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>std::vector</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/dce/namespacestan.html#d0/dc1/structstan_1_1real__return" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00068">68</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="ga57121ded0440567e8dfb0d80b1290922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57121ded0440567e8dfb0d80b1290922">&#9670;&nbsp;</a></span>value_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">stan::value_type_t</a> = typedef typename <a class="el" href="../../da/dce/namespacestan.html#dd/d27/structstan_1_1value__type">value_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for accessing underlying type. </p>

<p class="definition">Definition at line <a class="el" href="../../df/dd4/prim_2meta_2value__type_8hpp_source.html#l00035">35</a> of file <a class="el" href="../../df/dd4/prim_2meta_2value__type_8hpp_source.html">value_type.hpp</a>.</p>

</div>
</div>
<a id="ga1b070b6ae219eccccf07b44243307b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b070b6ae219eccccf07b44243307b8b">&#9670;&nbsp;</a></span>vector_return_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga1b070b6ae219eccccf07b44243307b8b">stan::vector_return_t</a> = typedef Eigen::Matrix&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt;Ts...&gt;, -1, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, 1&gt;</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/dce/namespacestan.html#d0/dc1/structstan_1_1real__return" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00092">92</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacd89dca2a48f398e759d882af2e62ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd89dca2a48f398e759d882af2e62ddd">&#9670;&nbsp;</a></span>build() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op1 , typename Op2 , typename Op3 , typename Op4 , typename Op5 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> <a class="el" href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html">stan::math::operands_and_partials</a>&lt; Op1, Op2, Op3, Op4, Op5, <a class="el" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;::build </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build the node to be stored on the autodiff graph. This should contain both the value and the tangent.</p>
<p>For scalars, we don't calculate any tangents. For reverse mode, we end up returning a type of var that will calculate the appropriate adjoint using the stored operands and partials. Forward mode just calculates the tangent on the spot and returns it in a vanilla fvar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the return value of the function we are compressing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node to be stored in the expression graph for autodiff </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d00/rev_2functor_2operands__and__partials_8hpp_source.html#l00147">147</a> of file <a class="el" href="../../d9/d00/rev_2functor_2operands__and__partials_8hpp_source.html">operands_and_partials.hpp</a>.</p>

</div>
</div>
<a id="ga52df2941f0acddad6251d218d9d62668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52df2941f0acddad6251d218d9d62668">&#9670;&nbsp;</a></span>build() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op1 , typename Op2 , typename Op3 , typename Op4 , typename Op5 , typename T_return_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html">stan::math::operands_and_partials</a>&lt; Op1, Op2, Op3, Op4, Op5, T_return_type &gt;::build </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build the node to be stored on the autodiff graph. This should contain both the value and the tangent.</p>
<p>For scalars (this implementation), we don't calculate any derivatives. For reverse mode, we end up returning a type of var that will calculate the appropriate adjoint using the stored operands and partials. Forward mode just calculates the tangent on the spot and returns it in a vanilla fvar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the return value of the function we are compressing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value with its derivative </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d0c/prim_2functor_2operands__and__partials_8hpp_source.html#l00142">142</a> of file <a class="el" href="../../d8/d0c/prim_2functor_2operands__and__partials_8hpp_source.html">operands_and_partials.hpp</a>.</p>

</div>
</div>
<a id="gae29786dab3b9274d3f1d08f6904854eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae29786dab3b9274d3f1d08f6904854eb">&#9670;&nbsp;</a></span>build() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op1 , typename Op2 , typename Op3 , typename Op4 , typename Op5 , typename Dx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/dcd/classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01fvar_3_01_dx_01_4_01_4.html#afce03dc72ef9b35eb9045d3c7b060fd5">T_return_type</a> <a class="el" href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html">stan::math::operands_and_partials</a>&lt; Op1, Op2, Op3, Op4, Op5, <a class="el" href="../../d0/dfb/structstan_1_1math_1_1fvar.html">fvar</a>&lt; Dx &gt; &gt;::build </td>
          <td>(</td>
          <td class="paramtype">Dx&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build the node to be stored on the autodiff graph. This should contain both the value and the tangent.</p>
<p>For scalars, we don't calculate any tangents. For reverse mode, we end up returning a type of var that will calculate the appropriate adjoint using the stored operands and partials. Forward mode just calculates the tangent on the spot and returns it in a vanilla fvar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the return value of the function we are compressing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value with its derivative </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d8e/fwd_2functor_2operands__and__partials_8hpp_source.html#l00104">104</a> of file <a class="el" href="../../da/d8e/fwd_2functor_2operands__and__partials_8hpp_source.html">operands_and_partials.hpp</a>.</p>

</div>
</div>
<a id="ga354e6529ea257ab6475be87e7c217ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga354e6529ea257ab6475be87e7c217ce9">&#9670;&nbsp;</a></span>col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga3a19896be493116fa4a1092abde79e61">require_eigen_t</a>&lt; T &gt; &gt;::col </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga6cc77bba018fff06dd1f0f0f2d79e5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc77bba018fff06dd1f0f0f2d79e5b9">&#9670;&nbsp;</a></span>forward_as() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;              !std::is_same&lt;std::decay&lt;T_actual&gt;, std::decay&lt;T_desired&gt;&gt;::value              &amp;&amp; (!is_eigen&lt;T_desired&gt;::value || !is_eigen&lt;T_actual&gt;::value)&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_desired stan::math::forward_as </td>
          <td>(</td>
          <td class="paramtype">const T_actual &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assume which type we get. If actual type is not convertible to assumed type or in case of eigen types compile time rows and columns are not the same and desired sizes are not dynamic this has return type of <code>T_desired</code>, but it only throws. This version should only be used where it is optimized away so the throw should never happen.</p>
<p>This is intended to be used in compile time branches that would otherwise trigger compile error even though they are never executed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_desired</td><td>type of output we need to avoid compile time errors </td></tr>
    <tr><td class="paramname">T_actual</td><td>actual type of the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing, this always throws </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">always</td><td>throws std::runtime_error </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d1/df7/forward__as_8hpp_source.html#l00061">61</a> of file <a class="el" href="../../d1/df7/forward__as_8hpp_source.html">forward_as.hpp</a>.</p>

</div>
</div>
<a id="ga0af4c158839e8c4c401e0f7e78bb4dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0af4c158839e8c4c401e0f7e78bb4dc6">&#9670;&nbsp;</a></span>forward_as() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T_actual&gt;,                                          std::decay_t&lt;T_desired&gt;&gt;::value                             &amp;&amp; !is_eigen&lt;T_desired&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_actual&amp;&amp; stan::math::forward_as </td>
          <td>(</td>
          <td class="paramtype">T_actual &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assume which type we get. If actual type is convertible to assumed type or in case of eigen types compile time rows and columns also match or desired sizes are dynamic this is a no-op. Otherwise it throws std::runtime_error, which should never happen if used as intended.</p>
<p>This is intended to be used in compile time branches that would otherwise trigger compile error even though they are never executed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_desired</td><td>type of output we need to avoid compile time errors </td></tr>
    <tr><td class="paramname">T_actual</td><td>actual type of the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input value a </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d1/df7/forward__as_8hpp_source.html#l00037">37</a> of file <a class="el" href="../../d1/df7/forward__as_8hpp_source.html">forward_as.hpp</a>.</p>

</div>
</div>
<a id="ga385d807274aa40985a59c273d49cf9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga385d807274aa40985a59c273d49cf9cd">&#9670;&nbsp;</a></span>forward_as() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_desired , typename T_actual , require_eigen_t&lt; T_desired &gt; *  = nullptr, std::enable_if_t&lt; std::is_same&lt; value_type_t&lt; T_actual &gt;, value_type_t&lt; T_desired &gt;&gt;::value &amp;&amp;is_eigen&lt; T_desired &gt;::value &amp;&amp;is_eigen&lt; T_actual &gt;::value &amp;&amp;internal::eigen_static_size_match(T_desired::RowsAtCompileTime, std::decay_t&lt; T_actual &gt;::RowsAtCompileTime) &amp;&amp;internal::eigen_static_size_match(T_desired::ColsAtCompileTime, std::decay_t&lt; T_actual &gt;::ColsAtCompileTime)&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_actual&amp;&amp; stan::math::forward_as </td>
          <td>(</td>
          <td class="paramtype">T_actual &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assume which type we get. If actual type is convertible to assumed type or in case of eigen types compile time rows and columns also match or desired sizes are dynamic this is a no-op. Otherwise it throws std::runtime_error, which should never happen if used as intended.</p>
<p>This is intended to be used in compile time branches that would otherwise trigger compile error even though they are never executed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_desired</td><td>type of output we need to avoid compile time errors </td></tr>
    <tr><td class="paramname">T_actual</td><td>actual type of the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input value a </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d1/df7/forward__as_8hpp_source.html#l00091">91</a> of file <a class="el" href="../../d1/df7/forward__as_8hpp_source.html">forward_as.hpp</a>.</p>

</div>
</div>
<a id="ga431bd201f09a215cccb16cda10a1e840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga431bd201f09a215cccb16cda10a1e840">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::get </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the n-th element of the provided std::vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector </td></tr>
    <tr><td class="paramname">n</td><td>index of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n-th element of the input vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d95/get_8hpp_source.html#l00035">35</a> of file <a class="el" href="../../dc/d95/get_8hpp_source.html">get.hpp</a>.</p>

</div>
</div>
<a id="gad2a93cdd718b76d4994d0f7c6c05fbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2a93cdd718b76d4994d0f7c6c05fbba">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::get </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the provided element. Scalar type overload for the function to retrieve n-th element of a vector, <code><a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a></code> <code>Matrix</code> or expression</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input scalar </td></tr>
    <tr><td class="paramname">n</td><td>index of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input scalar </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d95/get_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../dc/d95/get_8hpp_source.html">get.hpp</a>.</p>

</div>
</div>
<a id="ga80a702889907a3c12704df6c514fcc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80a702889907a3c12704df6c514fcc07">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ViewElt&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga3a19896be493116fa4a1092abde79e61">require_eigen_t</a>&lt; T &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga84d157dabee552a681aa5e4406b86474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84d157dabee552a681aa5e4406b86474">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga3a19896be493116fa4a1092abde79e61">require_eigen_t</a>&lt; T &gt; &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d19/classstan_1_1math_1_1internal_1_1empty__broadcast__array_3_01_view_elt_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#ae60f68cce56bd8855479f31c9d37ca50">T_arg</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga50070330d69c12c87811fcaf4e643803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50070330d69c12c87811fcaf4e643803">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga3a19896be493116fa4a1092abde79e61">require_eigen_t</a>&lt; T &gt; &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d19/classstan_1_1math_1_1internal_1_1empty__broadcast__array_3_01_view_elt_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#ae60f68cce56bd8855479f31c9d37ca50">T_arg</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga501ec44e68851a8396f5f693e35a2e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga501ec44e68851a8396f5f693e35a2e69">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga3a19896be493116fa4a1092abde79e61">require_eigen_t</a>&lt; T &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d19/classstan_1_1math_1_1internal_1_1empty__broadcast__array_3_01_view_elt_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#ae60f68cce56bd8855479f31c9d37ca50">T_arg</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga390dff20f30679c8e57ca2c3efe6d766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga390dff20f30679c8e57ca2c3efe6d766">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S , typename Enable  = void&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; T, S, Enable &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga9b28065e82cdcee1c320a7120cb8a83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b28065e82cdcee1c320a7120cb8a83d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d5/dbd/classstan_1_1math_1_1internal_1_1broadcast__array.html">stan::math::internal::broadcast_array</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Broadcast array can be assigned a scalar or a vector. If assigned a scalar, it will be used directly. If assigned a vector, the argument will be summed first. </p>

<p class="definition">Definition at line <a class="el" href="../../d4/df8/broadcast__array_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../d4/df8/broadcast__array_8hpp_source.html">broadcast_array.hpp</a>.</p>

</div>
</div>
<a id="ga0bc34a86c0bb1a9853b36aa4c952a4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bc34a86c0bb1a9853b36aa4c952a4dc">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S , typename Enable  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; T, S, Enable &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="gaf06037332423259c9f5fa57c9b72ad3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf06037332423259c9f5fa57c9b72ad3b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ViewElt&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga3a19896be493116fa4a1092abde79e61">require_eigen_t</a>&lt; T &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga8fd58c5861f0ee94465a97f78b2a00f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fd58c5861f0ee94465a97f78b2a00f0">&#9670;&nbsp;</a></span>row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga3a19896be493116fa4a1092abde79e61">require_eigen_t</a>&lt; T &gt; &gt;::row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga98afb6ae5281b82b30caa793e205f6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98afb6ae5281b82b30caa793e205f6ae">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size (number of the elements) of a <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> or <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt;<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;T&gt;&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input to determine size of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements in m</dd></dl>
<p>Returns the length of primitive scalar types that are always of length 1.</p>
<p>Returns the size of the provided <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix, expression or std::vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input <code><a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a></code> <code>Matrix</code>, expression or std::vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of m </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/df3/opencl_2prim_2size_8hpp_source.html#l00018">18</a> of file <a class="el" href="../../de/df3/opencl_2prim_2size_8hpp_source.html">size.hpp</a>.</p>

</div>
</div>
<a id="gab9a1e2f6c725ab45a9a0d5335ae9b0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9a1e2f6c725ab45a9a0d5335ae9b0c1">&#9670;&nbsp;</a></span>size_mvt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT , require_stan_scalar_t&lt; ScalarT &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::size_mvt </td>
          <td>(</td>
          <td class="paramtype">const ScalarT &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the size of a multivariate argument.</p>
<p>This is the default template function. For any scalar type, this will throw an std::invalid_argument exception since a scalar is not a multivariate structure.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to take size of. The default template function should only match scalars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>since the type is a scalar. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/da6/size__mvt_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../d2/da6/size__mvt_8hpp_source.html">size_mvt.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
