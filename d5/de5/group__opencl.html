<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: OpenCL</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../$standoxy.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">4.3.2</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d5/de5/group__opencl.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpenCL</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Stan's OpenCL backend allows for computation to be executed in parallel on a GPU or in multithreaded CPUs. It is meant to easily conform with <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> such that you can create and read from a <code>matrix_cl</code> by doing. </p>
<div class="fragment"><div class="line">Eigen::MatrixXd A_eig = Eigen::MatrixXd::Random(10, 10);</div>
<div class="line">matrix_cl&lt;double&gt; A(A_eig);</div>
<div class="line">matrix_cl&lt;double&gt; B = <a class="code" href="../../d5/de5/group__opencl.html#ga8bbce98664097d5ea8e55b0b931bd721">to_matrix_cl</a>(A_eig);</div>
<div class="line">matrix_cl&lt;double&gt; C = <a class="code" href="../../dc/d5d/group__opencl__kernels.html#gacdabec78c1cd7feac6047ddd6289800d">cholesky_decompose</a>(A * B);</div>
<div class="line"><span class="comment">// Read back to eigen matrix.</span></div>
<div class="line">Eigen::MatrixXd C_eig = <a class="code" href="../../d5/de5/group__opencl.html#gadf2a61125c6dca5e5a400d56e24cc6d5">from_matrix_cl</a>(C);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Also for vectors and raw pointers of pointers</span></div>
<div class="line">std::vector&lt;var&gt; A_vec(10, 0);</div>
<div class="line">matrix_cl&lt;var&gt; B_var(A_vec, 10, 1);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="../../d4/d84/namespacestan_1_1math.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a>** A_vari= <span class="comment">// fill</span></div>
<div class="line">matrix_cl&lt;var&gt; B_vari(A_vari, 10, 1);</div>
</div><!-- fragment --><p>Execution is performed in async and Kernel operations are compounded and compiled Just In Time. This allows for a low amount of overhead when passing data to and from the device and executing computations.</p>
<p>For more details see the paper on Arvix. <a href="https://arxiv.org/pdf/1907.01063.pdf">https://arxiv.org/pdf/1907.01063.pdf</a> </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d2/d3c/group__opencl__kernel__generator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3c/group__opencl__kernel__generator.html">OpenCL Kernel Generator</a></td></tr>
<tr class="memdesc:d2/d3c/group__opencl__kernel__generator"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OpenCL kernel generator is used to combine multiple matrix operations into a single OpenCL kernel. This is much simpler than writing multi-operation kernels by hand. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d34/group__matrix__cl__group"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d34/group__matrix__cl__group.html">Matrix</a></td></tr>
<tr class="memdesc:d3/d34/group__matrix__cl__group"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> class - allocates memory space on the OpenCL device. Operations on <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> types are executed lazily via the kernel generator and async routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d5f/group__opencl__context__group"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d5f/group__opencl__context__group.html">OpenCL Context</a></td></tr>
<tr class="memdesc:de/d5f/group__opencl__context__group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for OpenCL Context: <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/d32/group__error__checks__opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d32/group__error__checks__opencl.html">Error Checks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/def/group__kernel__executor__opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/def/group__kernel__executor__opencl.html">Kernel Executor</a></td></tr>
<tr class="memdesc:dd/def/group__kernel__executor__opencl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kernel executor allows OpenCL kernels to be executed in async. GPUs have the capability to perform reads, writes, and computation at the same time. In order to maximize the throughput to the device the Kernel Executor assigns matrices read and write events. Write events are blocking in that no further operations can be completed until the write event is finished. However, read events can happen in async together. Take the following for example. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d5d/group__opencl__kernels"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d5d/group__opencl__kernels.html">Custom OpenCL kernels</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/de3/group__prim__fun__opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de3/group__prim__fun__opencl.html">OpenCL overloads of stan/math/prim functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga55b628b5a271afb9f569c34187fd82ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_floating_point_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga55b628b5a271afb9f569c34187fd82ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga55b628b5a271afb9f569c34187fd82ad">stan::math::opencl::cholesky_decompose</a> (<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:ga55b628b5a271afb9f569c34187fd82ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bbce98664097d5ea8e55b0b931bd721"><td class="memTemplParams" colspan="2">template&lt;typename T , require_st_arithmetic&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8bbce98664097d5ea8e55b0b931bd721"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga8bbce98664097d5ea8e55b0b931bd721">stan::math::to_matrix_cl</a> (T &amp;&amp;src)</td></tr>
<tr class="separator:ga8bbce98664097d5ea8e55b0b931bd721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , require_eigen_t&lt; T_ret &gt; *  = nullptr, require_matrix_cl_t&lt; T &gt; *  = nullptr, require_st_same&lt; T_ret, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gadf2a61125c6dca5e5a400d56e24cc6d5">stan::math::from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad35b73b8bb6ac116683220a20f4c317d"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr, require_not_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad35b73b8bb6ac116683220a20f4c317d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gad35b73b8bb6ac116683220a20f4c317d">stan::math::from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:gad35b73b8bb6ac116683220a20f4c317d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e84cc75a88ea72d01c090997fdc556"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , require_arithmetic_t&lt; T &gt; *  = nullptr, require_same_t&lt; T_dst, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga44e84cc75a88ea72d01c090997fdc556"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga44e84cc75a88ea72d01c090997fdc556">stan::math::from_matrix_cl</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="separator:ga44e84cc75a88ea72d01c090997fdc556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f99f6ae3dd35f205631e839119f5541"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1f99f6ae3dd35f205631e839119f5541"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga1f99f6ae3dd35f205631e839119f5541">stan::math::from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:ga1f99f6ae3dd35f205631e839119f5541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490df7651c22c9e06d09da69ad303e30"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga490df7651c22c9e06d09da69ad303e30"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga490df7651c22c9e06d09da69ad303e30">stan::math::packed_copy</a> (const T &amp;src)</td></tr>
<tr class="separator:ga490df7651c22c9e06d09da69ad303e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memTemplParams" colspan="2">template&lt;matrix_cl_view matrix_view, typename Vec , typename Vec_scalar  = scalar_type_t&lt;Vec&gt;, require_vector_vt&lt; std::is_arithmetic, Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; Vec_scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaed1f7da1a49ff3c2a9e1147b4eef4662">stan::math::packed_copy</a> (Vec &amp;&amp;src, int <a class="el" href="../../d5/de5/group__opencl.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e">rows</a>)</td></tr>
<tr class="separator:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60406331fe144c5088b62ab261a04e87"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga60406331fe144c5088b62ab261a04e87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/dce/namespacestan.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga60406331fe144c5088b62ab261a04e87">stan::math::copy_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:ga60406331fe144c5088b62ab261a04e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9850bbd8d516b87d722ad54947bb9c9f">stan::math::either</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> left_view, const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> right_view)</td></tr>
<tr class="separator:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338a285d4ba933ba6aa7240908919e0f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga338a285d4ba933ba6aa7240908919e0f">stan::math::both</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> left_view, const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> right_view)</td></tr>
<tr class="separator:ga338a285d4ba933ba6aa7240908919e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd63c8a601189c916c8a2157066adb7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gadd63c8a601189c916c8a2157066adb7c">stan::math::contains_nonzero</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view, const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> part)</td></tr>
<tr class="separator:gadd63c8a601189c916c8a2157066adb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccee2b081b9edd7c6e6d211157e5490"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gafccee2b081b9edd7c6e6d211157e5490">stan::math::transpose</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view)</td></tr>
<tr class="separator:gafccee2b081b9edd7c6e6d211157e5490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747f014e58d824281b725a7d4868dd77"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga747f014e58d824281b725a7d4868dd77">stan::math::invert</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view)</td></tr>
<tr class="separator:ga747f014e58d824281b725a7d4868dd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e938e6fdd621c5903cc37401c54909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga27e938e6fdd621c5903cc37401c54909">stan::math::from_eigen_uplo_type</a> (Eigen::UpLoType eigen_type)</td></tr>
<tr class="separator:ga27e938e6fdd621c5903cc37401c54909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga72e3539ba6e81a0a69e69f09c683252a">stan::math::multiply_transpose</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41aad12d4ca13a5ae0117d586fb276bf"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_x_cl , typename T_y_cl , typename T_alpha_cl , typename T_beta_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga41aad12d4ca13a5ae0117d586fb276bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga41aad12d4ca13a5ae0117d586fb276bf">stan::math::bernoulli_logit_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga41aad12d4ca13a5ae0117d586fb276bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f362f28acd7dfc21fc0df158e8b4df8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4f362f28acd7dfc21fc0df158e8b4df8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga4f362f28acd7dfc21fc0df158e8b4df8">stan::math::bernoulli_lpmf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="separator:ga4f362f28acd7dfc21fc0df158e8b4df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25bf99f6c2b660ff1bfcdb0bc8440b1d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_size1_cl , typename T_size2_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_size1_cl, T_size2_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_size1_cl, T_size2_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga25bf99f6c2b660ff1bfcdb0bc8440b1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_size1_cl, T_size2_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga25bf99f6c2b660ff1bfcdb0bc8440b1d">stan::math::beta_binomial_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_size1_cl &amp;alpha, const T_size2_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga25bf99f6c2b660ff1bfcdb0bc8440b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f3979f0dfb2cfe557bb00f5a420819d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_succ_cl , typename T_scale_fail_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6f3979f0dfb2cfe557bb00f5a420819d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga6f3979f0dfb2cfe557bb00f5a420819d">stan::math::beta_lpdf</a> (const T_y_cl &amp;y, const T_scale_succ_cl &amp;alpha, const T_scale_fail_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga6f3979f0dfb2cfe557bb00f5a420819d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695bf141835176b401725a1f93c0b00b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_prec_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga695bf141835176b401725a1f93c0b00b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_prec_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga695bf141835176b401725a1f93c0b00b">stan::math::beta_proportion_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_prec_cl &amp;kappa)</td></tr>
<tr class="separator:ga695bf141835176b401725a1f93c0b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b70ff8b7c0976aa9443ff63026ee3d7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, require_any_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6b70ff8b7c0976aa9443ff63026ee3d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga6b70ff8b7c0976aa9443ff63026ee3d7">stan::math::binomial_logit_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_prob_cl &amp;alpha)</td></tr>
<tr class="separator:ga6b70ff8b7c0976aa9443ff63026ee3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e355b2eb2a94840f0d2d8df923fc9a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, require_any_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga12e355b2eb2a94840f0d2d8df923fc9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga12e355b2eb2a94840f0d2d8df923fc9a">stan::math::binomial_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_prob_cl &amp;theta)</td></tr>
<tr class="separator:ga12e355b2eb2a94840f0d2d8df923fc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d57691e9a780ada257fb9a3573f7d9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_all_prim_or_rev_kernel_expression_t&lt; T_y, T_x, T_alpha, T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga44d57691e9a780ada257fb9a3573f7d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga44d57691e9a780ada257fb9a3573f7d9">stan::math::categorical_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga44d57691e9a780ada257fb9a3573f7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47eebee38b750df11f0d6d6aebefd319"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga47eebee38b750df11f0d6d6aebefd319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga47eebee38b750df11f0d6d6aebefd319">stan::math::cauchy_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga47eebee38b750df11f0d6d6aebefd319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f591b741316b1eba4a2965646029037"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6f591b741316b1eba4a2965646029037"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga6f591b741316b1eba4a2965646029037">stan::math::cauchy_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga6f591b741316b1eba4a2965646029037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ebf1445eace512163f719b3c6153127"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5ebf1445eace512163f719b3c6153127"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga5ebf1445eace512163f719b3c6153127">stan::math::cauchy_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga5ebf1445eace512163f719b3c6153127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5bc2b295d24a0a13675f8f3465a224"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e5bc2b295d24a0a13675f8f3465a224"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga5e5bc2b295d24a0a13675f8f3465a224">stan::math::cauchy_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga5e5bc2b295d24a0a13675f8f3465a224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c220c07244b0448c4743e1a447f27e3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4c220c07244b0448c4743e1a447f27e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga4c220c07244b0448c4743e1a447f27e3">stan::math::chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu)</td></tr>
<tr class="separator:ga4c220c07244b0448c4743e1a447f27e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0576c38beac678f1164a2cfc172e941e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:ga0576c38beac678f1164a2cfc172e941e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga0576c38beac678f1164a2cfc172e941e">stan::math::col</a> (T_x &amp;&amp;x, size_t j)</td></tr>
<tr class="separator:ga0576c38beac678f1164a2cfc172e941e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d4c5b2fb1164cd7dddf3d303785022"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga89d4c5b2fb1164cd7dddf3d303785022"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga89d4c5b2fb1164cd7dddf3d303785022">stan::math::cols</a> (const T_x &amp;x)</td></tr>
<tr class="separator:ga89d4c5b2fb1164cd7dddf3d303785022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaff473895b1f11e364afd4c2d3cb5cab4">stan::math::dims</a> (const T_x &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="separator:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e6c08d7c0cccd3786a7742b135b9a52"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob_cl , typename T_prior_size_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_prob_cl, T_prior_size_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_prob_cl, T_prior_size_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2e6c08d7c0cccd3786a7742b135b9a52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl, T_prior_size_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga2e6c08d7c0cccd3786a7742b135b9a52">stan::math::dirichlet_lpdf</a> (const T_prob_cl &amp;theta, const T_prior_size_cl &amp;alpha)</td></tr>
<tr class="separator:ga2e6c08d7c0cccd3786a7742b135b9a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_a&gt;&gt; </td></tr>
<tr class="memitem:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga7fcb23d1bea081595030aedd230f5cf9">stan::math::divide</a> (T_a &amp;&amp;a, double d)</td></tr>
<tr class="separator:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga2cc44cdfe2d3632d1e5481cff15fb65b">stan::math::divide_columns</a> (<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;B)</td></tr>
<tr class="separator:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eb269aa25fab63bb03b617210151e4a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga8eb269aa25fab63bb03b617210151e4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga8eb269aa25fab63bb03b617210151e4a">stan::math::divide_columns</a> (<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const T2 &amp;divisor)</td></tr>
<tr class="separator:ga8eb269aa25fab63bb03b617210151e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad684c5d3a421b9467f49e310f4de4a79"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad684c5d3a421b9467f49e310f4de4a79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gad684c5d3a421b9467f49e310f4de4a79">stan::math::double_exponential_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gad684c5d3a421b9467f49e310f4de4a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f5affb2425a19cb23eae6f34f9bc73c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3f5affb2425a19cb23eae6f34f9bc73c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga3f5affb2425a19cb23eae6f34f9bc73c">stan::math::double_exponential_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga3f5affb2425a19cb23eae6f34f9bc73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f8a5af1fc2ad20f7c010879c778b2e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga88f8a5af1fc2ad20f7c010879c778b2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga88f8a5af1fc2ad20f7c010879c778b2e">stan::math::double_exponential_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga88f8a5af1fc2ad20f7c010879c778b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32141185398679bb00fe1ce2ba9b66c1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga32141185398679bb00fe1ce2ba9b66c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga32141185398679bb00fe1ce2ba9b66c1">stan::math::double_exponential_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga32141185398679bb00fe1ce2ba9b66c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a9ac563ae060b1db31a94d691ba2ce0"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6a9ac563ae060b1db31a94d691ba2ce0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga6a9ac563ae060b1db31a94d691ba2ce0">stan::math::exp_mod_normal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="separator:ga6a9ac563ae060b1db31a94d691ba2ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae195effc04066eebadd16c6e241dec57"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae195effc04066eebadd16c6e241dec57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gae195effc04066eebadd16c6e241dec57">stan::math::exp_mod_normal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="separator:gae195effc04066eebadd16c6e241dec57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa835b5a8631edc35a37662f355d4b0d6"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa835b5a8631edc35a37662f355d4b0d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaa835b5a8631edc35a37662f355d4b0d6">stan::math::exp_mod_normal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="separator:gaa835b5a8631edc35a37662f355d4b0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2860333c4eb25602dc10a31f5f817fb1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2860333c4eb25602dc10a31f5f817fb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga2860333c4eb25602dc10a31f5f817fb1">stan::math::exp_mod_normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="separator:ga2860333c4eb25602dc10a31f5f817fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa924ac4e31732ac4be2e7328d1d7bff5"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa924ac4e31732ac4be2e7328d1d7bff5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaa924ac4e31732ac4be2e7328d1d7bff5">stan::math::exponential_cdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaa924ac4e31732ac4be2e7328d1d7bff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21b7eecccc6bcf97c9dce23b75ec6b62"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga21b7eecccc6bcf97c9dce23b75ec6b62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga21b7eecccc6bcf97c9dce23b75ec6b62">stan::math::exponential_lccdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga21b7eecccc6bcf97c9dce23b75ec6b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f8b7c07c493376a4d55cfe84b560221"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0f8b7c07c493376a4d55cfe84b560221"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga0f8b7c07c493376a4d55cfe84b560221">stan::math::exponential_lcdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga0f8b7c07c493376a4d55cfe84b560221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef8076d4800bf09044f6b2d3206ee8de"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaef8076d4800bf09044f6b2d3206ee8de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaef8076d4800bf09044f6b2d3206ee8de">stan::math::exponential_lpdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaef8076d4800bf09044f6b2d3206ee8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70979bb911b646ed0c080be88bb9123e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga70979bb911b646ed0c080be88bb9123e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga70979bb911b646ed0c080be88bb9123e">stan::math::frechet_cdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga70979bb911b646ed0c080be88bb9123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ac156a8c64a383499955efb6be062c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae5ac156a8c64a383499955efb6be062c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gae5ac156a8c64a383499955efb6be062c">stan::math::frechet_lccdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gae5ac156a8c64a383499955efb6be062c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b1c13dae5e208ae2b700b63d3997a45"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2b1c13dae5e208ae2b700b63d3997a45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga2b1c13dae5e208ae2b700b63d3997a45">stan::math::frechet_lcdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga2b1c13dae5e208ae2b700b63d3997a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40919e3150ee05b80682f46cde802c22"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga40919e3150ee05b80682f46cde802c22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga40919e3150ee05b80682f46cde802c22">stan::math::frechet_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga40919e3150ee05b80682f46cde802c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3964605bbb452f539ad82458a1a7cc07"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3964605bbb452f539ad82458a1a7cc07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga3964605bbb452f539ad82458a1a7cc07">stan::math::gamma_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_inv_scale_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga3964605bbb452f539ad82458a1a7cc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , require_all_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr, require_stan_scalar_t&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga7ae66d06eb626b8357a5fc74289bfe42">stan::math::gp_dot_prod_cov</a> (const T_x &amp;x, const T_sigma sigma)</td></tr>
<tr class="separator:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb569d6717740727352a2b67d23adfc"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_y , typename T_sigma , require_all_prim_or_rev_kernel_expression_t&lt; T_x, T_y &gt; *  = nullptr, require_stan_scalar_t&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadfb569d6717740727352a2b67d23adfc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gadfb569d6717740727352a2b67d23adfc">stan::math::gp_dot_prod_cov</a> (const T_x &amp;x, const T_y &amp;y, const T_sigma sigma)</td></tr>
<tr class="separator:gadfb569d6717740727352a2b67d23adfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa686087fcae5e7016b355ceb3cf45846"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename  = require_all_arithmetic_t&lt;T1, T2, T3&gt;&gt; </td></tr>
<tr class="memitem:gaa686087fcae5e7016b355ceb3cf45846"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaa686087fcae5e7016b355ceb3cf45846">stan::math::gp_exp_quad_cov</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="separator:gaa686087fcae5e7016b355ceb3cf45846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename  = require_all_arithmetic_t&lt;T1, T2, T3, T4&gt;&gt; </td></tr>
<tr class="memitem:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9ebc1c13865b66015a0f30739b18b28f">stan::math::gp_exp_quad_cov</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;x, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="separator:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac47f7d0f97a1035236ac74de3b965020"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_kernel_expressions_and_none_scalar_t&lt; T1 &gt; *  = nullptr, require_all_arithmetic_t&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac47f7d0f97a1035236ac74de3b965020"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gac47f7d0f97a1035236ac74de3b965020">stan::math::gp_exponential_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="separator:gac47f7d0f97a1035236ac74de3b965020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ac2500cbe6777efe781d2738148ed4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr, require_all_arithmetic_t&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga63ac2500cbe6777efe781d2738148ed4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga63ac2500cbe6777efe781d2738148ed4">stan::math::gp_exponential_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="separator:ga63ac2500cbe6777efe781d2738148ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_kernel_expressions_and_none_scalar_t&lt; T1 &gt; *  = nullptr, require_all_arithmetic_t&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga42d71e19927c390c7e2ca70ffe71d600">stan::math::gp_matern32_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="separator:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr, require_all_arithmetic_t&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga85aa537a04d32939114f7dd8b75fdc5b">stan::math::gp_matern32_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="separator:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5e4b95241432025c0dbf5693659fda"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_kernel_expressions_and_none_scalar_t&lt; T1 &gt; *  = nullptr, require_all_arithmetic_t&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaea5e4b95241432025c0dbf5693659fda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaea5e4b95241432025c0dbf5693659fda">stan::math::gp_matern52_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="separator:gaea5e4b95241432025c0dbf5693659fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07fab169578cad9bff602bc9c60453a7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr, require_all_arithmetic_t&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga07fab169578cad9bff602bc9c60453a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga07fab169578cad9bff602bc9c60453a7">stan::math::gp_matern52_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="separator:ga07fab169578cad9bff602bc9c60453a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b361cf5a03a7fd55cf5ab3b3d1c285d"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2b361cf5a03a7fd55cf5ab3b3d1c285d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga2b361cf5a03a7fd55cf5ab3b3d1c285d">stan::math::gumbel_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga2b361cf5a03a7fd55cf5ab3b3d1c285d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dded1ca1056f57bf752bccda74ae6b0"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9dded1ca1056f57bf752bccda74ae6b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9dded1ca1056f57bf752bccda74ae6b0">stan::math::gumbel_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga9dded1ca1056f57bf752bccda74ae6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf55abc2c3182268292a063a51c87b6b"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabf55abc2c3182268292a063a51c87b6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gabf55abc2c3182268292a063a51c87b6b">stan::math::gumbel_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gabf55abc2c3182268292a063a51c87b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa88407c66c8c8de7bf26c1d8eadaff84"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa88407c66c8c8de7bf26c1d8eadaff84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaa88407c66c8c8de7bf26c1d8eadaff84">stan::math::gumbel_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaa88407c66c8c8de7bf26c1d8eadaff84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32df5b5541df60cd45e329bf067f000"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac32df5b5541df60cd45e329bf067f000"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gac32df5b5541df60cd45e329bf067f000">stan::math::inv_chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu)</td></tr>
<tr class="separator:gac32df5b5541df60cd45e329bf067f000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0332105689b4e9992e99166c4f3e12"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7e0332105689b4e9992e99166c4f3e12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga7e0332105689b4e9992e99166c4f3e12">stan::math::inv_gamma_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga7e0332105689b4e9992e99166c4f3e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae089d318dec46d3eecab353ccedd07ab"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae089d318dec46d3eecab353ccedd07ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gae089d318dec46d3eecab353ccedd07ab">stan::math::logistic_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gae089d318dec46d3eecab353ccedd07ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e1cb21d2e8927cf2458ea675ec832c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga11e1cb21d2e8927cf2458ea675ec832c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga11e1cb21d2e8927cf2458ea675ec832c">stan::math::logistic_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga11e1cb21d2e8927cf2458ea675ec832c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga790f7ff43cded1271978779ae5bc5f8b"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga790f7ff43cded1271978779ae5bc5f8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga790f7ff43cded1271978779ae5bc5f8b">stan::math::logistic_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga790f7ff43cded1271978779ae5bc5f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aa767c6b4a5636db46932992cae075b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9aa767c6b4a5636db46932992cae075b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9aa767c6b4a5636db46932992cae075b">stan::math::logistic_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga9aa767c6b4a5636db46932992cae075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69167b3ae3de102c803fa7b227e9d11f"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga69167b3ae3de102c803fa7b227e9d11f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga69167b3ae3de102c803fa7b227e9d11f">stan::math::lognormal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga69167b3ae3de102c803fa7b227e9d11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2383f947a55d9b0ef8104fc6c84a83ad"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2383f947a55d9b0ef8104fc6c84a83ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga2383f947a55d9b0ef8104fc6c84a83ad">stan::math::lognormal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga2383f947a55d9b0ef8104fc6c84a83ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9495fcb0a2a223bbf0219e7805bbc487"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9495fcb0a2a223bbf0219e7805bbc487"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9495fcb0a2a223bbf0219e7805bbc487">stan::math::lognormal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga9495fcb0a2a223bbf0219e7805bbc487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae14854b2ed4e8eed637cdeb8f8d15dbb"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae14854b2ed4e8eed637cdeb8f8d15dbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gae14854b2ed4e8eed637cdeb8f8d15dbb">stan::math::lognormal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gae14854b2ed4e8eed637cdeb8f8d15dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dbda02859731a08444a98d74777f846"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_covar_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_covar_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3dbda02859731a08444a98d74777f846"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_covar_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga3dbda02859731a08444a98d74777f846">stan::math::multi_normal_cholesky_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_covar_cl &amp;L)</td></tr>
<tr class="separator:ga3dbda02859731a08444a98d74777f846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed19f70ae3520d9ef8c982dace013e8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga6ed19f70ae3520d9ef8c982dace013e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga6ed19f70ae3520d9ef8c982dace013e8">stan::math::multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="separator:ga6ed19f70ae3520d9ef8c982dace013e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb16f794da8d9e6341f2543fbab56237"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_phi_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacb16f794da8d9e6341f2543fbab56237"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gacb16f794da8d9e6341f2543fbab56237">stan::math::neg_binomial_2_log_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_phi_cl &amp;phi)</td></tr>
<tr class="separator:gacb16f794da8d9e6341f2543fbab56237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1c0e8c6edb035b297e73193f8cd820"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_log_location_cl , typename T_precision_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7c1c0e8c6edb035b297e73193f8cd820"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga7c1c0e8c6edb035b297e73193f8cd820">stan::math::neg_binomial_2_log_lpmf</a> (const T_n_cl &amp;n, const T_log_location_cl &amp;eta, const T_precision_cl &amp;phi)</td></tr>
<tr class="separator:ga7c1c0e8c6edb035b297e73193f8cd820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3956bcf1b6e3aac673b7b89f2f9b4d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_location_cl , typename T_precision_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0f3956bcf1b6e3aac673b7b89f2f9b4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_location_cl, T_precision_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga0f3956bcf1b6e3aac673b7b89f2f9b4d">stan::math::neg_binomial_2_lpmf</a> (const T_n_cl &amp;n, const T_location_cl &amp;mu, const T_precision_cl &amp;phi)</td></tr>
<tr class="separator:ga0f3956bcf1b6e3aac673b7b89f2f9b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb77966b5ca780cac193dfeb6e7dc7f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_shape_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaacb77966b5ca780cac193dfeb6e7dc7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaacb77966b5ca780cac193dfeb6e7dc7f">stan::math::neg_binomial_lpmf</a> (const T_n_cl &amp;n, const T_shape_cl &amp;alpha, const T_inv_scale_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaacb77966b5ca780cac193dfeb6e7dc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5778a9ae4790a5fe723a4d963f721df0"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5778a9ae4790a5fe723a4d963f721df0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga5778a9ae4790a5fe723a4d963f721df0">stan::math::normal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga5778a9ae4790a5fe723a4d963f721df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c799735f974356f8d1ab7743960a65"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_sigma_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf3c799735f974356f8d1ab7743960a65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaf3c799735f974356f8d1ab7743960a65">stan::math::normal_id_glm_lpdf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_sigma_cl &amp;sigma)</td></tr>
<tr class="separator:gaf3c799735f974356f8d1ab7743960a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ffb7c87522de6e24c7c95fa71b2e116"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4ffb7c87522de6e24c7c95fa71b2e116"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga4ffb7c87522de6e24c7c95fa71b2e116">stan::math::normal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga4ffb7c87522de6e24c7c95fa71b2e116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7b2d28bf1c40f0f9ec609d73f1011b2"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa7b2d28bf1c40f0f9ec609d73f1011b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaa7b2d28bf1c40f0f9ec609d73f1011b2">stan::math::normal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gaa7b2d28bf1c40f0f9ec609d73f1011b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98a15165135ddb986e4f74cb66817ba"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab98a15165135ddb986e4f74cb66817ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gab98a15165135ddb986e4f74cb66817ba">stan::math::normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gab98a15165135ddb986e4f74cb66817ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363eead878eb45fb01517e94ac7d4f4b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_beta , typename T_cuts , require_all_prim_or_rev_kernel_expression_t&lt; T_y, T_x, T_beta, T_cuts &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga363eead878eb45fb01517e94ac7d4f4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_beta, T_cuts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga363eead878eb45fb01517e94ac7d4f4b">stan::math::ordered_logistic_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_beta &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_cuts &amp;cuts)</td></tr>
<tr class="separator:ga363eead878eb45fb01517e94ac7d4f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2fa71e9871a9b2f6f720de72177c1f3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_cuts_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_cuts_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa2fa71e9871a9b2f6f720de72177c1f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_cuts_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaa2fa71e9871a9b2f6f720de72177c1f3">stan::math::ordered_logistic_lpmf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;lambda, const T_cuts_cl &amp;cuts)</td></tr>
<tr class="separator:gaa2fa71e9871a9b2f6f720de72177c1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ac10a703e5d01d02700b4effea8d05"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga99ac10a703e5d01d02700b4effea8d05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga99ac10a703e5d01d02700b4effea8d05">stan::math::pareto_cdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga99ac10a703e5d01d02700b4effea8d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4792e29b438cf1e3a244d26734ec5c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaab4792e29b438cf1e3a244d26734ec5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaab4792e29b438cf1e3a244d26734ec5c">stan::math::pareto_lccdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:gaab4792e29b438cf1e3a244d26734ec5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab314951f2c8314308e593e4c23b8d601"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab314951f2c8314308e593e4c23b8d601"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gab314951f2c8314308e593e4c23b8d601">stan::math::pareto_lcdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:gab314951f2c8314308e593e4c23b8d601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5e8eec1c27b30ea994f94070adc148"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7b5e8eec1c27b30ea994f94070adc148"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga7b5e8eec1c27b30ea994f94070adc148">stan::math::pareto_lpdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga7b5e8eec1c27b30ea994f94070adc148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f33022936713376f9d3e19daaf9430"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga17f33022936713376f9d3e19daaf9430"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga17f33022936713376f9d3e19daaf9430">stan::math::pareto_type_2_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga17f33022936713376f9d3e19daaf9430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d34272be0ff43f1e882232ac4af9c0"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga72d34272be0ff43f1e882232ac4af9c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga72d34272be0ff43f1e882232ac4af9c0">stan::math::pareto_type_2_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga72d34272be0ff43f1e882232ac4af9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac04043a4074079cda307e5bc219cb4be"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac04043a4074079cda307e5bc219cb4be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gac04043a4074079cda307e5bc219cb4be">stan::math::pareto_type_2_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:gac04043a4074079cda307e5bc219cb4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a333811247fce0ea707ce959dffa38"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga83a333811247fce0ea707ce959dffa38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga83a333811247fce0ea707ce959dffa38">stan::math::pareto_type_2_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga83a333811247fce0ea707ce959dffa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd6c49794202989a029ff70567f55479"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacd6c49794202989a029ff70567f55479"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gacd6c49794202989a029ff70567f55479">stan::math::poisson_log_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gacd6c49794202989a029ff70567f55479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1dba179f6258a2e07a30bdbe97255a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_log_rate_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5b1dba179f6258a2e07a30bdbe97255a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_rate_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga5b1dba179f6258a2e07a30bdbe97255a">stan::math::poisson_log_lpmf</a> (const T_n_cl &amp;n, const T_log_rate_cl &amp;alpha)</td></tr>
<tr class="separator:ga5b1dba179f6258a2e07a30bdbe97255a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfdbbaacbab1d90d71290edc806bace3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_rate_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_rate_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_rate_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabfdbbaacbab1d90d71290edc806bace3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gabfdbbaacbab1d90d71290edc806bace3">stan::math::poisson_lpmf</a> (const T_n_cl &amp;n, const T_rate_cl &amp;lambda)</td></tr>
<tr class="separator:gabfdbbaacbab1d90d71290edc806bace3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91408855ed53a17cd6f385acb2f43fc"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab91408855ed53a17cd6f385acb2f43fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gab91408855ed53a17cd6f385acb2f43fc">stan::math::rayleigh_cdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gab91408855ed53a17cd6f385acb2f43fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26d27cf0c3966c101f0ea1c271f560d1"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga26d27cf0c3966c101f0ea1c271f560d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga26d27cf0c3966c101f0ea1c271f560d1">stan::math::rayleigh_lccdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga26d27cf0c3966c101f0ea1c271f560d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4eb053f40231980929911c9cb2f7b7"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1b4eb053f40231980929911c9cb2f7b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga1b4eb053f40231980929911c9cb2f7b7">stan::math::rayleigh_lcdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga1b4eb053f40231980929911c9cb2f7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga601d163c824e05147660da53e4099bd9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga601d163c824e05147660da53e4099bd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga601d163c824e05147660da53e4099bd9">stan::math::rayleigh_lpdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga601d163c824e05147660da53e4099bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_any_t&lt; is_matrix_cl&lt; T &gt;, math::conjunction&lt; is_var&lt; T &gt;, is_matrix_cl&lt; value_type_t&lt; T &gt;&gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga3bbe5a508d5789497afc2cbd03f8004c">stan::math::rep_array</a> (const <a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="separator:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga5e2c7f71203a6ba2b93d5372ed6cf01e">stan::math::rep_matrix</a> (const <a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &amp;x, int n, int m)</td></tr>
<tr class="separator:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f19ec991d6f0ed60695ef33003868d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_arithmetic_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga78f19ec991d6f0ed60695ef33003868d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga78f19ec991d6f0ed60695ef33003868d">stan::math::rep_matrix</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;x, int m)</td></tr>
<tr class="separator:ga78f19ec991d6f0ed60695ef33003868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbac6d303d27c8ee22511862dce6c565"><td class="memTemplParams" colspan="2">template&lt;typename T , require_any_t&lt; is_matrix_cl&lt; T &gt;, math::conjunction&lt; is_var&lt; T &gt;, is_matrix_cl&lt; value_type_t&lt; T &gt;&gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabbac6d303d27c8ee22511862dce6c565"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gabbac6d303d27c8ee22511862dce6c565">stan::math::rep_row_vector</a> (const <a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="separator:gabbac6d303d27c8ee22511862dce6c565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memTemplParams" colspan="2">template&lt;typename T , require_any_t&lt; is_matrix_cl&lt; T &gt;, math::conjunction&lt; is_var&lt; T &gt;, is_matrix_cl&lt; value_type_t&lt; T &gt;&gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gabd9fbe441671cf2a2f88cd3e8d9b8ca8">stan::math::rep_vector</a> (const <a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="separator:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80392ae5670adea53e79770aa29c816a"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:ga80392ae5670adea53e79770aa29c816a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga80392ae5670adea53e79770aa29c816a">stan::math::row</a> (T_x &amp;&amp;x, size_t j)</td></tr>
<tr class="separator:ga80392ae5670adea53e79770aa29c816a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61254f29c1520f4bffe4ab4e5bbd0e0e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga61254f29c1520f4bffe4ab4e5bbd0e0e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e">stan::math::rows</a> (const T_x &amp;x)</td></tr>
<tr class="separator:ga61254f29c1520f4bffe4ab4e5bbd0e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga106d028bb360d5c31554ec3495cc41d0"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga106d028bb360d5c31554ec3495cc41d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga106d028bb360d5c31554ec3495cc41d0">stan::math::scaled_inv_chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu, const T_scale_cl &amp;s)</td></tr>
<tr class="separator:ga106d028bb360d5c31554ec3495cc41d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadacfcfb973fe5c0ab2dac931e50b511e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadacfcfb973fe5c0ab2dac931e50b511e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gadacfcfb973fe5c0ab2dac931e50b511e">stan::math::skew_double_exponential_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="separator:gadacfcfb973fe5c0ab2dac931e50b511e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ec8f9f1a5acb9c6dc9e3640a204bda"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga36ec8f9f1a5acb9c6dc9e3640a204bda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga36ec8f9f1a5acb9c6dc9e3640a204bda">stan::math::skew_double_exponential_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="separator:ga36ec8f9f1a5acb9c6dc9e3640a204bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f57073fbf4146f1b66cd5ea4336af7d"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9f57073fbf4146f1b66cd5ea4336af7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9f57073fbf4146f1b66cd5ea4336af7d">stan::math::skew_double_exponential_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="separator:ga9f57073fbf4146f1b66cd5ea4336af7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354bf670629966ea8ff1397c3ea6a6a6"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga354bf670629966ea8ff1397c3ea6a6a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga354bf670629966ea8ff1397c3ea6a6a6">stan::math::skew_double_exponential_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="separator:ga354bf670629966ea8ff1397c3ea6a6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac950822e01ad7173a9f42c571933eb06"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac950822e01ad7173a9f42c571933eb06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gac950822e01ad7173a9f42c571933eb06">stan::math::skew_normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:gac950822e01ad7173a9f42c571933eb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38acf71383b36f5db4ed878c9415b7d4"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga38acf71383b36f5db4ed878c9415b7d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga38acf71383b36f5db4ed878c9415b7d4">stan::math::std_normal_cdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="separator:ga38acf71383b36f5db4ed878c9415b7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d733b180253da7249ae23e4e9bda790"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3d733b180253da7249ae23e4e9bda790"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga3d733b180253da7249ae23e4e9bda790">stan::math::std_normal_lccdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="separator:ga3d733b180253da7249ae23e4e9bda790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c94cfff116dc2477617f242e356ede"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac4c94cfff116dc2477617f242e356ede"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gac4c94cfff116dc2477617f242e356ede">stan::math::std_normal_lcdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="separator:gac4c94cfff116dc2477617f242e356ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48200e7b64861fad93fcdf7b24c8cac4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga48200e7b64861fad93fcdf7b24c8cac4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga48200e7b64861fad93fcdf7b24c8cac4">stan::math::std_normal_lpdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="separator:ga48200e7b64861fad93fcdf7b24c8cac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a3e85cdcb831735bf845adf1c42e234"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8a3e85cdcb831735bf845adf1c42e234"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga8a3e85cdcb831735bf845adf1c42e234">stan::math::student_t_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga8a3e85cdcb831735bf845adf1c42e234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaccde2dd41ea6e10cce3f5fd53dbfa0ea">stan::math::to_array_1d</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memTemplItemLeft" align="right" valign="top">T_x&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gae58346dcff1afcdf893e0c0e2ab7fbe3">stan::math::to_array_2d</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aabc784b5f56edb079f21a48efdad54"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0aabc784b5f56edb079f21a48efdad54"><td class="memTemplItemLeft" align="right" valign="top">T_x&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga0aabc784b5f56edb079f21a48efdad54">stan::math::to_matrix</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:ga0aabc784b5f56edb079f21a48efdad54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a3715205cf6c1564a87de73c13c22a"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga08a3715205cf6c1564a87de73c13c22a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga08a3715205cf6c1564a87de73c13c22a">stan::math::to_row_vector</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:ga08a3715205cf6c1564a87de73c13c22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0026608053df548f73f9556ffa94dc03"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0026608053df548f73f9556ffa94dc03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga0026608053df548f73f9556ffa94dc03">stan::math::to_vector</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:ga0026608053df548f73f9556ffa94dc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e86538bd3a160cb58989ff68aa81456"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0e86538bd3a160cb58989ff68aa81456"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga0e86538bd3a160cb58989ff68aa81456">stan::math::uniform_cdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga0e86538bd3a160cb58989ff68aa81456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2dacadd5737ffbb65288cef66d1cfb7"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab2dacadd5737ffbb65288cef66d1cfb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gab2dacadd5737ffbb65288cef66d1cfb7">stan::math::uniform_lccdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gab2dacadd5737ffbb65288cef66d1cfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga260dc4fb650cc809b40e338144ccbf1e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga260dc4fb650cc809b40e338144ccbf1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga260dc4fb650cc809b40e338144ccbf1e">stan::math::uniform_lcdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga260dc4fb650cc809b40e338144ccbf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c081c9922500bedd293b98080c246a9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8c081c9922500bedd293b98080c246a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga8c081c9922500bedd293b98080c246a9">stan::math::uniform_lpdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga8c081c9922500bedd293b98080c246a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f96945c94514afc7c296e5ed4f461e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga02f96945c94514afc7c296e5ed4f461e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga02f96945c94514afc7c296e5ed4f461e">stan::math::weibull_cdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga02f96945c94514afc7c296e5ed4f461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga143c39f3c5b17a11b8fac657716a1ca8"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga143c39f3c5b17a11b8fac657716a1ca8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga143c39f3c5b17a11b8fac657716a1ca8">stan::math::weibull_lccdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga143c39f3c5b17a11b8fac657716a1ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77ff0157eda0b5a11c6cacd5bcc07e42"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga77ff0157eda0b5a11c6cacd5bcc07e42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga77ff0157eda0b5a11c6cacd5bcc07e42">stan::math::weibull_lcdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga77ff0157eda0b5a11c6cacd5bcc07e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ecf070a86a3bb30c08ced16a1c1bb32"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9ecf070a86a3bb30c08ced16a1c1bb32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9ecf070a86a3bb30c08ced16a1c1bb32">stan::math::weibull_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga9ecf070a86a3bb30c08ced16a1c1bb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46313382ff3fae62c662662f93290572"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga46313382ff3fae62c662662f93290572"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga46313382ff3fae62c662662f93290572">stan::math::to_matrix_cl</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:ga46313382ff3fae62c662662f93290572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a35989520c40a236b8870762dd0db0"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga34a35989520c40a236b8870762dd0db0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga34a35989520c40a236b8870762dd0db0">stan::math::to_matrix_cl</a> (const std::vector&lt; <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt;&gt; &amp;a)</td></tr>
<tr class="separator:ga34a35989520c40a236b8870762dd0db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga095903e22c477b60e69e174c307bd423"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga095903e22c477b60e69e174c307bd423"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga095903e22c477b60e69e174c307bd423">stan::math::to_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:ga095903e22c477b60e69e174c307bd423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga824d07dfec68229d759d260c865e9747"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga824d07dfec68229d759d260c865e9747"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga824d07dfec68229d759d260c865e9747">stan::math::to_matrix_cl</a> (const std::vector&lt; T &gt; &amp;src)</td></tr>
<tr class="separator:ga824d07dfec68229d759d260c865e9747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , require_var_vt&lt; is_eigen, T_dst &gt; *  = nullptr, require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaedf3e76a11e9efeae4a1215bfb67c8be">stan::math::from_matrix_cl</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , require_std_vector_vt&lt; is_var, T_dst &gt; *  = nullptr, require_all_stan_scalar_t&lt; value_type_t&lt; T_dst &gt;&gt; *  = nullptr, require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga016b4e7e4fd48ee3333c5c37507e3d01">stan::math::from_matrix_cl</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaeefdbbf87e96786f8460982c80c5c06f">stan::math::from_matrix_cl</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="separator:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5c33973a4c2311bf3f9284149208417"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , require_var_vt&lt; is_matrix_cl, T_ret &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf5c33973a4c2311bf3f9284149208417"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaf5c33973a4c2311bf3f9284149208417">stan::math::rep_matrix</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;A, int n, int m)</td></tr>
<tr class="separator:gaf5c33973a4c2311bf3f9284149208417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57212223aca8e2c1999b268efacecf33"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga57212223aca8e2c1999b268efacecf33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga57212223aca8e2c1999b268efacecf33">stan::math::rep_matrix</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt; &amp;A, int m)</td></tr>
<tr class="separator:ga57212223aca8e2c1999b268efacecf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ff9a795bfa5ae75421d00a95e8a6c0"><td class="memTemplParams" colspan="2">template&lt;matrix_cl_view matrix_view = matrix_cl_view::Entire, typename T , require_matrix_cl_st&lt; std::is_floating_point, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga57ff9a795bfa5ae75421d00a95e8a6c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/dce/namespacestan.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga57ff9a795bfa5ae75421d00a95e8a6c0">stan::math::tri_inverse</a> (const T &amp;A)</td></tr>
<tr class="separator:ga57ff9a795bfa5ae75421d00a95e8a6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga41aad12d4ca13a5ae0117d586fb276bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41aad12d4ca13a5ae0117d586fb276bf">&#9670;&nbsp;</a></span>bernoulli_logit_glm_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_x_cl , typename T_y_cl , typename T_alpha_cl , typename T_beta_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_x_cl, T_alpha_cl, T_beta_cl&gt; stan::math::bernoulli_logit_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x_cl &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PMF of the Generalized Linear Model (GLM) with Bernoulli distribution and logit link function. This is an overload of the GLM in <a class="el" href="../../d2/d4c/prim_2prob_2bernoulli__logit__glm__lpmf_8hpp.html">prim/prob/bernoulli_logit_glm_lpmf.hpp</a> that is implemented in OpenCL. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of independent variable; this can be a <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> vector of intercepts or a single value (wich will be broadcast - used for all instances); </td></tr>
    <tr><td class="paramname">T_x_cl</td><td>type of the design matrix </td></tr>
    <tr><td class="paramname">T_alpha_cl</td><td>type of the intercept(s); this can be a vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta_cl</td><td>type of the weight vector; this can also be a single value; </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>binary scalar or vector parameter on OpenCL device. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not binary. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d6/dfd/opencl_2prim_2bernoulli__logit__glm__lpmf_8hpp_source.html#l00056">56</a> of file <a class="el" href="../../d6/dfd/opencl_2prim_2bernoulli__logit__glm__lpmf_8hpp_source.html">bernoulli_logit_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga4f362f28acd7dfc21fc0df158e8b4df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f362f28acd7dfc21fc0df158e8b4df8">&#9670;&nbsp;</a></span>bernoulli_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_prob_cl&gt; stan::math::bernoulli_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob_cl &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PMF of the Bernoulli distribution. If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of integer parameters </td></tr>
    <tr><td class="paramname">T_prob_cl</td><td>type of chance of success parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>integer parameter </td></tr>
    <tr><td class="paramname">theta</td><td>chance of success parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if theta is not a valid probability </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d1/d6d/opencl_2prim_2bernoulli__lpmf_8hpp_source.html#l00032">32</a> of file <a class="el" href="../../d1/d6d/opencl_2prim_2bernoulli__lpmf_8hpp_source.html">bernoulli_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga25bf99f6c2b660ff1bfcdb0bc8440b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25bf99f6c2b660ff1bfcdb0bc8440b1d">&#9670;&nbsp;</a></span>beta_binomial_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_size1_cl , typename T_size2_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_size1_cl, T_size2_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_size1_cl, T_size2_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_n_cl, T_size1_cl, T_size2_cl&gt; stan::math::beta_binomial_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N_cl&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_size1_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_size2_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PMF of the Beta-Binomial distribution with given population size, prior success, and prior failure parameters. Given containers of matching sizes, returns the log sum of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n</td><td>type of success parameter </td></tr>
    <tr><td class="paramname">T_N</td><td>type of population size parameter </td></tr>
    <tr><td class="paramname">T_size1</td><td>type of prior success parameter </td></tr>
    <tr><td class="paramname">T_size2</td><td>type of prior failure parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>success parameter </td></tr>
    <tr><td class="paramname">N</td><td>population size parameter </td></tr>
    <tr><td class="paramname">alpha</td><td>prior success parameter </td></tr>
    <tr><td class="paramname">beta</td><td>prior failure parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if N, alpha, or beta fails to be positive </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/dd3/opencl_2prim_2beta__binomial__lpmf_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../d7/dd3/opencl_2prim_2beta__binomial__lpmf_8hpp_source.html">beta_binomial_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga6f3979f0dfb2cfe557bb00f5a420819d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f3979f0dfb2cfe557bb00f5a420819d">&#9670;&nbsp;</a></span>beta_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_scale_succ_cl , typename T_scale_fail_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_scale_succ_cl, T_scale_fail_cl&gt; stan::math::beta_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_succ_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_fail_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of the beta density for the specified scalar(s) given the specified sample stan::math::size(s). y, alpha, or beta can each either be scalar or a vector on OpenCL device. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/alpha/beta triple.</p>
<p>Prior sample sizes, alpha and beta, must be greater than 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_scale_succ_cl</td><td>type of prior scale for successes </td></tr>
    <tr><td class="paramname">T_scale_fail_cl</td><td>type of prior scale for failures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) prior sample stan::math::size(s). </td></tr>
    <tr><td class="paramname">beta</td><td>(Sequence of) prior sample stan::math::size(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d1/d82/opencl_2prim_2beta__lpdf_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../d1/d82/opencl_2prim_2beta__lpdf_8hpp_source.html">beta_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga695bf141835176b401725a1f93c0b00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga695bf141835176b401725a1f93c0b00b">&#9670;&nbsp;</a></span>beta_proportion_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_prec_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_prec_cl&gt; stan::math::beta_proportion_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prec_cl &amp;&#160;</td>
          <td class="paramname"><em>kappa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of the beta density for specified y, location, and precision: beta_proportion_lpdf(y | mu, kappa) = beta_lpdf(y | mu * kappa, (1 - mu) * kappa). Any arguments other than scalars must be containers of the same size. With non-scalar arguments, the return is the sum of the log pdfs with scalars broadcast as necessary.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mu/kappa triple.</p>
<p>Prior location, mu, must be contained in (0, 1). Prior precision must be positive.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of prior location </td></tr>
    <tr><td class="paramname">T_prec_cl</td><td>type of prior precision</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) dependant variable(s) </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">kappa</td><td>(Sequence of) precision parameter(s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../db/dd8/opencl_2prim_2beta__proportion__lpdf_8hpp_source.html#l00042">42</a> of file <a class="el" href="../../db/dd8/opencl_2prim_2beta__proportion__lpdf_8hpp_source.html">beta_proportion_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga6b70ff8b7c0976aa9443ff63026ee3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b70ff8b7c0976aa9443ff63026ee3d7">&#9670;&nbsp;</a></span>binomial_logit_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, require_any_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_prob_cl&gt; stan::math::binomial_logit_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N_cl&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binomial log PMF in logit parametrization. Binomial(n|n, inv_logit(alpha))</p>
<p>If given vectors of matching lengths, returns the log sum of probabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>successes variable </td></tr>
    <tr><td class="paramname">N</td><td>population size parameter </td></tr>
    <tr><td class="paramname">alpha</td><td>logit transformed probability parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if N is negative or probability parameter is invalid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if vector sizes do not match </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../db/dcd/opencl_2prim_2binomial__logit__lpmf_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../db/dcd/opencl_2prim_2binomial__logit__lpmf_8hpp_source.html">binomial_logit_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga12e355b2eb2a94840f0d2d8df923fc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12e355b2eb2a94840f0d2d8df923fc9a">&#9670;&nbsp;</a></span>binomial_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, require_any_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_prob_cl&gt; stan::math::binomial_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N_cl&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob_cl &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PMF for the binomial distribution evaluated at the specified success, population size, and chance of success. If given containers of matching lengths, returns the log sum of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of successes parameter </td></tr>
    <tr><td class="paramname">T_N_cl</td><td>type of population size parameter </td></tr>
    <tr><td class="paramname">T_prob_cl</td><td>type of chance of success parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>successes parameter </td></tr>
    <tr><td class="paramname">N</td><td>population size parameter </td></tr>
    <tr><td class="paramname">theta</td><td>chance of success parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if n is negative or greater than N </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if N is negative </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if theta is not a valid probability </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../db/d48/opencl_2prim_2binomial__lpmf_8hpp_source.html#l00036">36</a> of file <a class="el" href="../../db/d48/opencl_2prim_2binomial__lpmf_8hpp_source.html">binomial_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga338a285d4ba933ba6aa7240908919e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga338a285d4ba933ba6aa7240908919e0f">&#9670;&nbsp;</a></span>both()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> stan::math::both </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>left_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>right_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines which parts are nonzero in both input views. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_view</td><td>first view </td></tr>
    <tr><td class="paramname">right_view</td><td>second view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>common nonzero part </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00032">32</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="ga44d57691e9a780ada257fb9a3573f7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44d57691e9a780ada257fb9a3573f7d9">&#9670;&nbsp;</a></span>categorical_logit_glm_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_all_prim_or_rev_kernel_expression_t&lt; T_y, T_x, T_alpha, T_beta &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_x, T_alpha, T_beta&gt; stan::math::categorical_logit_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PMF of the Generalized Linear Model (GLM) with categorical distribution and logit (softmax) link function. This is an overload of the GLM in <a class="el" href="../../df/d55/prim_2prob_2categorical__logit__glm__lpmf_8hpp.html">prim/prob/categorical_logit_glm_lpmf.hpp</a> that is implemented in OpenCL.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_alpha</td><td>type of the intercept vector </td></tr>
    <tr><td class="paramname">T_beta</td><td>type of the matrix of weights </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>a scalar or vector of classes. If it is a scalar it will be broadcast - used for all instances. Values should be between 1 and number of classes, including endpoints. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept vector (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>x, beta or alpha is infinite or y is not within bounds </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d91/opencl_2prim_2categorical__logit__glm__lpmf_8hpp_source.html#l00049">49</a> of file <a class="el" href="../../d5/d91/opencl_2prim_2categorical__logit__glm__lpmf_8hpp_source.html">categorical_logit_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga47eebee38b750df11f0d6d6aebefd319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47eebee38b750df11f0d6d6aebefd319">&#9670;&nbsp;</a></span>cauchy_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::cauchy_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the cauchy cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d14/opencl_2prim_2cauchy__cdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../d5/d14/opencl_2prim_2cauchy__cdf_8hpp_source.html">cauchy_cdf.hpp</a>.</p>

</div>
</div>
<a id="ga6f591b741316b1eba4a2965646029037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f591b741316b1eba4a2965646029037">&#9670;&nbsp;</a></span>cauchy_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::cauchy_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the cauchy log complementary cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the log sum of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/dd9/opencl_2prim_2cauchy__lccdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../dd/dd9/opencl_2prim_2cauchy__lccdf_8hpp_source.html">cauchy_lccdf.hpp</a>.</p>

</div>
</div>
<a id="ga5ebf1445eace512163f719b3c6153127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ebf1445eace512163f719b3c6153127">&#9670;&nbsp;</a></span>cauchy_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::cauchy_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the cauchy cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d66/opencl_2prim_2cauchy__lcdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../df/d66/opencl_2prim_2cauchy__lcdf_8hpp_source.html">cauchy_lcdf.hpp</a>.</p>

</div>
</div>
<a id="ga5e5bc2b295d24a0a13675f8f3465a224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e5bc2b295d24a0a13675f8f3465a224">&#9670;&nbsp;</a></span>cauchy_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::cauchy_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of the Cauchy density for the specified scalar(s) given the specified location parameter(s) and scale parameter(s). y, mu, or sigma can each either be scalar a vector. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mu/sigma triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d25/opencl_2prim_2cauchy__lpdf_8hpp_source.html#l00038">38</a> of file <a class="el" href="../../d8/d25/opencl_2prim_2cauchy__lpdf_8hpp_source.html">cauchy_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga4c220c07244b0448c4743e1a447f27e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c220c07244b0448c4743e1a447f27e3">&#9670;&nbsp;</a></span>chi_square_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_dof_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_dof_cl&gt; stan::math::chi_square_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof_cl &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of a chi-squared density for y with the specified degrees of freedom parameter. The degrees of freedom parameter must be greater than 0. y must be greater than or equal to 0.</p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; \chi^2_\nu \\ \log (p (y \, |\, \nu)) &amp;=&amp; \log \left( \frac{2^{-\nu / 2}}{\Gamma (\nu / 2)} y^{\nu / 2 - 1} \exp^{- y / 2} \right) \\ &amp;=&amp; - \frac{\nu}{2} \log(2) - \log (\Gamma (\nu / 2)) + (\frac{\nu}{2} - 1) \log(y) - \frac{y}{2} \\ &amp; &amp; \mathrm{ where } \; y \ge 0 \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of dependent variable </td></tr>
    <tr><td class="paramname">T_dof_cl</td><td>type of degrees of freedom </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A dependent variable. </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than or equal to 0 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d0a/opencl_2prim_2chi__square__lpdf_8hpp_source.html#l00038">38</a> of file <a class="el" href="../../d5/d0a/opencl_2prim_2chi__square__lpdf_8hpp_source.html">chi_square_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga55b628b5a271afb9f569c34187fd82ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55b628b5a271afb9f569c34187fd82ad">&#9670;&nbsp;</a></span>cholesky_decompose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_floating_point_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::opencl::cholesky_decompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs an in-place computation of the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix. The return value \(L\) will be a lower-triangular matrix such that the original matrix \(A\) is given by </p>
<p>\(A = L \times L^T\). The Cholesky decomposition is computed using an OpenCL kernel. This algorithm is recursive. The matrix is subset into a matrix of size <code><a class="el" href="../../d5/de5/group__opencl.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e">A.rows()</a> / 4</code>, and if the submatrix size is less than 50 or <code>min_block</code> then the Cholesky decomposition on the OpenCL device is computed using that submatrix. If the submatrix is greater than 50 or <code>min_block</code> then <code>cholesky_decompose</code> is run again on a submatrix with size equal to <code><a class="el" href="../../d5/de5/group__opencl.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e">submat.rows()</a> / 4</code>. Once the Cholesky decomposition is computed, the full matrix Cholesky is created by propagating the Cholesky forward as given in the reference report below.</p>
<p>For a full guide to how this works see the Cholesky decomposition chapter in the reference report <a href="https://goo.gl/6kWkJ5">here</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if m is not positive definite (if m has more than 0 elements) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/df1/opencl_2cholesky__decompose_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../d7/df1/opencl_2cholesky__decompose_8hpp_source.html">cholesky_decompose.hpp</a>.</p>

</div>
</div>
<a id="ga0576c38beac678f1164a2cfc172e941e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0576c38beac678f1164a2cfc172e941e">&#9670;&nbsp;</a></span>col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::col </td>
          <td>(</td>
          <td class="paramtype">T_x &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the specified column of the specified kernel generator expression using start-at-1 indexing.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of input kernel generator expression a </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input kernel generator expression. </td></tr>
    <tr><td class="paramname">j</td><td>Column index (count from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified column of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if j is out of range. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dc8/opencl_2prim_2col_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../d0/dc8/opencl_2prim_2col_8hpp_source.html">col.hpp</a>.</p>

</div>
</div>
<a id="ga89d4c5b2fb1164cd7dddf3d303785022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89d4c5b2fb1164cd7dddf3d303785022">&#9670;&nbsp;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::cols </td>
          <td>(</td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of columns in the specified kernel generator expression.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of input kernel generator expression x </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input kernel generator expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of columns in x </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../db/de0/opencl_2prim_2cols_8hpp_source.html#l00020">20</a> of file <a class="el" href="../../db/de0/opencl_2prim_2cols_8hpp_source.html">cols.hpp</a>.</p>

</div>
</div>
<a id="gadd63c8a601189c916c8a2157066adb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd63c8a601189c916c8a2157066adb7c">&#9670;&nbsp;</a></span>contains_nonzero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::contains_nonzero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether a view contains certain nonzero part </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>view to check </td></tr>
    <tr><td class="paramname">part</td><td>part to check for (usually <code>Lower</code> or <code>Upper</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if <code>view</code> has <code>part</code> nonzero </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00045">45</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="ga60406331fe144c5088b62ab261a04e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60406331fe144c5088b62ab261a04e87">&#9670;&nbsp;</a></span>copy_cl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/dce/namespacestan.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt;T&gt; stan::math::copy_cl </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the source matrix to the destination matrix. Both matrices are stored on the OpenCL device.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An arithmetic type to pass the value from the OpenCL matrix to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> with copies of values in the source matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrices do not have matching dimensions </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00333">333</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="gaff473895b1f11e364afd4c2d3cb5cab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff473895b1f11e364afd4c2d3cb5cab4">&#9670;&nbsp;</a></span>dims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> overload of the dims helper function in <a class="el" href="../../d2/d7c/prim_2fun_2dims_8hpp.html">prim/fun/dims.hpp</a>. Pushes the rows and columns to the result vector argument.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of input kernel generator expression a </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>the input <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>the output vector of dimensions </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/opencl_2prim_2dims_8hpp_source.html#l00021">21</a> of file <a class="el" href="../../d5/dd9/opencl_2prim_2dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a id="ga2e6c08d7c0cccd3786a7742b135b9a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e6c08d7c0cccd3786a7742b135b9a52">&#9670;&nbsp;</a></span>dirichlet_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_prob_cl , typename T_prior_size_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_prob_cl, T_prior_size_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_prob_cl, T_prior_size_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_prob_cl, T_prior_size_cl&gt; stan::math::dirichlet_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_prob_cl &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prior_size_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The log of the Dirichlet density for the given theta and a vector of prior sample sizes, alpha. Each element of alpha must be greater than 0. Each element of theta must be greater than or 0. Theta sums to 1.</p>
<p class="formulaDsp">
\[ \theta\sim\mbox{Dirichlet}(\alpha_1,\ldots,\alpha_k)\\ \log(p(\theta\,|\,\alpha_1,\ldots,\alpha_k))=\log\left( \frac{\Gamma(\alpha_1+\cdots+\alpha_k)}{\Gamma(\alpha_1)+ \cdots+\Gamma(\alpha_k)}* \left(\theta_1^{\alpha_1-1}+ \cdots+\theta_k^{\alpha_k-1}\right)\right)\\ =\log(\Gamma(\alpha_1+\cdots+\alpha_k))-\left( \log(\Gamma(\alpha_1))+\cdots+\log(\Gamma(\alpha_k))\right)+ (\alpha_1-1)\log(\theta_1)+\cdots+(\alpha_k-1)\log(\theta_k) \]
</p>
<p class="formulaDsp">
\[ \frac{\partial }{\partial \theta_x}\log(p(\theta\,|\,\alpha_1,\ldots,\alpha_k))= \frac{\alpha_x-1}{\theta_x} \]
</p>
<p class="formulaDsp">
\[ \frac{\partial}{\partial\alpha_x}\log(p(\theta\,|\,\alpha_1,\ldots,\alpha_k)) =\psi_{(0)}(\sum\alpha)-\psi_{(0)}(\alpha_x)+\log\theta_x \]
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_prob</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_prior_size</td><td>type of prior sample sizes </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>A scalar vector. </td></tr>
    <tr><td class="paramname">alpha</td><td>Prior sample sizes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Dirichlet density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if any element of alpha is less than or equal to 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if any element of theta is less than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if the sum of theta is not 1. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/da2/opencl_2prim_2dirichlet__lpdf_8hpp_source.html#l00061">61</a> of file <a class="el" href="../../df/da2/opencl_2prim_2dirichlet__lpdf_8hpp_source.html">dirichlet_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga7fcb23d1bea081595030aedd230f5cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fcb23d1bea081595030aedd230f5cf9">&#9670;&nbsp;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_a , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_a&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">T_a &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the elementwise division of the kernel generator expression</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_a</td><td>type of input kernel generator expression a </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>expression to divide </td></tr>
    <tr><td class="paramname">d</td><td>scalar to divide by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the elements of expression a divided by d </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d89/opencl_2prim_2divide_8hpp_source.html#l00020">20</a> of file <a class="el" href="../../d6/d89/opencl_2prim_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a id="ga2cc44cdfe2d3632d1e5481cff15fb65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cc44cdfe2d3632d1e5481cff15fb65b">&#9670;&nbsp;</a></span>divide_columns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::divide_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides each column of a matrix by a vector</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first matrix </td></tr>
    <tr><td class="paramname">B</td><td>Vector of elements to divide each column of <code>A</code> by element-wise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>element-wise division of <code>A</code> by <code>B</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the input matrices do not have matching dimensions </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d73/opencl_2prim_2divide__columns_8hpp_source.html#l00030">30</a> of file <a class="el" href="../../d2/d73/opencl_2prim_2divide__columns_8hpp_source.html">divide_columns.hpp</a>.</p>

</div>
</div>
<a id="ga8eb269aa25fab63bb03b617210151e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eb269aa25fab63bb03b617210151e4a">&#9670;&nbsp;</a></span>divide_columns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::divide_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides each column of a matrix by a scalar</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the divisor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix to divide </td></tr>
    <tr><td class="paramname">divisor</td><td>scalar to divide by</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>element-wise division of <code>A</code> by <code>divisor</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d73/opencl_2prim_2divide__columns_8hpp_source.html#l00056">56</a> of file <a class="el" href="../../d2/d73/opencl_2prim_2divide__columns_8hpp_source.html">divide_columns.hpp</a>.</p>

</div>
</div>
<a id="gad684c5d3a421b9467f49e310f4de4a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad684c5d3a421b9467f49e310f4de4a79">&#9670;&nbsp;</a></span>double_exponential_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::double_exponential_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the double exponential cumulative density function. Given containers of matching sizes, returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/df2/opencl_2prim_2double__exponential__cdf_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../dc/df2/opencl_2prim_2double__exponential__cdf_8hpp_source.html">double_exponential_cdf.hpp</a>.</p>

</div>
</div>
<a id="ga3f5affb2425a19cb23eae6f34f9bc73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f5affb2425a19cb23eae6f34f9bc73c">&#9670;&nbsp;</a></span>double_exponential_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::double_exponential_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the double exponential log complementary cumulative density function. Given containers of matching sizes, returns the log sum of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/db2/opencl_2prim_2double__exponential__lccdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../df/db2/opencl_2prim_2double__exponential__lccdf_8hpp_source.html">double_exponential_lccdf.hpp</a>.</p>

</div>
</div>
<a id="ga88f8a5af1fc2ad20f7c010879c778b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88f8a5af1fc2ad20f7c010879c778b2e">&#9670;&nbsp;</a></span>double_exponential_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::double_exponential_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the double exponential log cumulative density function. Given containers of matching sizes, returns the log sum of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d15/opencl_2prim_2double__exponential__lcdf_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../d8/d15/opencl_2prim_2double__exponential__lcdf_8hpp_source.html">double_exponential_lcdf.hpp</a>.</p>

</div>
</div>
<a id="ga32141185398679bb00fe1ce2ba9b66c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32141185398679bb00fe1ce2ba9b66c1">&#9670;&nbsp;</a></span>double_exponential_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::double_exponential_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the double exponential log probability density function. Given containers of matching sizes, returns the log sum of densities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of real parameter. </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location parameter. </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>real parameter </td></tr>
    <tr><td class="paramname">mu</td><td>location parameter </td></tr>
    <tr><td class="paramname">sigma</td><td>scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability density or log sum of probability densities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is nan, mu is infinite, or sigma is nonpositive </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d9c/opencl_2prim_2double__exponential__lpdf_8hpp_source.html#l00036">36</a> of file <a class="el" href="../../d5/d9c/opencl_2prim_2double__exponential__lpdf_8hpp_source.html">double_exponential_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga9850bbd8d516b87d722ad54947bb9c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9850bbd8d516b87d722ad54947bb9c9f">&#9670;&nbsp;</a></span>either()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> stan::math::either </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>left_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>right_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines which parts are nonzero in any of the input views. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_view</td><td>first view </td></tr>
    <tr><td class="paramname">right_view</td><td>second view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>combined view </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00019">19</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="ga6a9ac563ae060b1db31a94d691ba2ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a9ac563ae060b1db31a94d691ba2ce0">&#9670;&nbsp;</a></span>exp_mod_normal_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl&gt; stan::math::exp_mod_normal_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the double exponential cumulative density function. Given containers of matching sizes, returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
    <tr><td class="paramname">lambda</td><td>(Sequence of) inverse scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d1a/opencl_2prim_2exp__mod__normal__cdf_8hpp_source.html#l00036">36</a> of file <a class="el" href="../../d7/d1a/opencl_2prim_2exp__mod__normal__cdf_8hpp_source.html">exp_mod_normal_cdf.hpp</a>.</p>

</div>
</div>
<a id="gae195effc04066eebadd16c6e241dec57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae195effc04066eebadd16c6e241dec57">&#9670;&nbsp;</a></span>exp_mod_normal_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl&gt; stan::math::exp_mod_normal_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the exp mod normal log complementary cumulative density function. Given containers of matching sizes, returns the log sum of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
    <tr><td class="paramname">lambda</td><td>(Sequence of) inverse scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d65/opencl_2prim_2exp__mod__normal__lccdf_8hpp_source.html#l00038">38</a> of file <a class="el" href="../../d8/d65/opencl_2prim_2exp__mod__normal__lccdf_8hpp_source.html">exp_mod_normal_lccdf.hpp</a>.</p>

</div>
</div>
<a id="gaa835b5a8631edc35a37662f355d4b0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa835b5a8631edc35a37662f355d4b0d6">&#9670;&nbsp;</a></span>exp_mod_normal_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl&gt; stan::math::exp_mod_normal_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the exp mod normal log cumulative density function. Given containers of matching sizes, returns the log sum of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
    <tr><td class="paramname">lambda</td><td>(Sequence of) inverse scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/def/opencl_2prim_2exp__mod__normal__lcdf_8hpp_source.html#l00037">37</a> of file <a class="el" href="../../da/def/opencl_2prim_2exp__mod__normal__lcdf_8hpp_source.html">exp_mod_normal_lcdf.hpp</a>.</p>

</div>
</div>
<a id="ga2860333c4eb25602dc10a31f5f817fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2860333c4eb25602dc10a31f5f817fb1">&#9670;&nbsp;</a></span>exp_mod_normal_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl&gt; stan::math::exp_mod_normal_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PMF of the exp mod normal distribution. If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of dependent variable </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of inverse scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>dependent variable </td></tr>
    <tr><td class="paramname">mu</td><td>location </td></tr>
    <tr><td class="paramname">sigma</td><td>scale </td></tr>
    <tr><td class="paramname">lambda</td><td>inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is NaN, mu is infinite, sigma is negative or infinite or lambda is negative or infinite. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/dc0/opencl_2prim_2exp__mod__normal__lpdf_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../da/dc0/opencl_2prim_2exp__mod__normal__lpdf_8hpp_source.html">exp_mod_normal_lpdf.hpp</a>.</p>

</div>
</div>
<a id="gaa924ac4e31732ac4be2e7328d1d7bff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa924ac4e31732ac4be2e7328d1d7bff5">&#9670;&nbsp;</a></span>exponential_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_inv_scale_cl&gt; stan::math::exponential_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the exponential cumulative distribution function for the given y and beta.</p>
<p>Inverse scale parameter must be greater than 0. y must be greater than or equal to 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>a scalar variable </td></tr>
    <tr><td class="paramname">beta</td><td>inverse scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of densities </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d19/opencl_2prim_2exponential__cdf_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../de/d19/opencl_2prim_2exponential__cdf_8hpp_source.html">exponential_cdf.hpp</a>.</p>

</div>
</div>
<a id="ga21b7eecccc6bcf97c9dce23b75ec6b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21b7eecccc6bcf97c9dce23b75ec6b62">&#9670;&nbsp;</a></span>exponential_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_inv_scale_cl&gt; stan::math::exponential_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the log exponential cumulative distribution function for the given y and beta.</p>
<p>Inverse scale parameter must be greater than 0. y must be greater than or equal to 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>a scalar variable </td></tr>
    <tr><td class="paramname">beta</td><td>inverse scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d15/opencl_2prim_2exponential__lccdf_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../d6/d15/opencl_2prim_2exponential__lccdf_8hpp_source.html">exponential_lccdf.hpp</a>.</p>

</div>
</div>
<a id="ga0f8b7c07c493376a4d55cfe84b560221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f8b7c07c493376a4d55cfe84b560221">&#9670;&nbsp;</a></span>exponential_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_inv_scale_cl&gt; stan::math::exponential_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the log exponential cumulative distribution function for the given y and beta.</p>
<p>Inverse scale parameter must be greater than 0. y must be greater than or equal to 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>a scalar variable </td></tr>
    <tr><td class="paramname">beta</td><td>inverse scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d7a/opencl_2prim_2exponential__lcdf_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../d2/d7a/opencl_2prim_2exponential__lcdf_8hpp_source.html">exponential_lcdf.hpp</a>.</p>

</div>
</div>
<a id="gaef8076d4800bf09044f6b2d3206ee8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef8076d4800bf09044f6b2d3206ee8de">&#9670;&nbsp;</a></span>exponential_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_inv_scale_cl&gt; stan::math::exponential_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of an exponential density for y with the specified inverse scale parameter. Inverse scale parameter must be greater than 0. y must be greater than or equal to 0.</p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{Expon}}(\beta) \\ \log (p (y \, |\, \beta) ) &amp;=&amp; \log \left( \beta \exp^{-\beta y} \right) \\ &amp;=&amp; \log (\beta) - \beta y \\ &amp; &amp; \mathrm{where} \; y &gt; 0 \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">beta</td><td>Inverse scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if beta is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/db8/opencl_2prim_2exponential__lpdf_8hpp_source.html#l00047">47</a> of file <a class="el" href="../../d2/db8/opencl_2prim_2exponential__lpdf_8hpp_source.html">exponential_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga70979bb911b646ed0c080be88bb9123e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70979bb911b646ed0c080be88bb9123e">&#9670;&nbsp;</a></span>frechet_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_shape_cl, T_scale_cl&gt; stan::math::frechet_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the frechet cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/dd1/opencl_2prim_2frechet__cdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../de/dd1/opencl_2prim_2frechet__cdf_8hpp_source.html">frechet_cdf.hpp</a>.</p>

</div>
</div>
<a id="gae5ac156a8c64a383499955efb6be062c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5ac156a8c64a383499955efb6be062c">&#9670;&nbsp;</a></span>frechet_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_shape_cl, T_scale_cl&gt; stan::math::frechet_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the frechet log complementary cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d3c/opencl_2prim_2frechet__lccdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../d6/d3c/opencl_2prim_2frechet__lccdf_8hpp_source.html">frechet_lccdf.hpp</a>.</p>

</div>
</div>
<a id="ga2b1c13dae5e208ae2b700b63d3997a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b1c13dae5e208ae2b700b63d3997a45">&#9670;&nbsp;</a></span>frechet_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_shape_cl, T_scale_cl&gt; stan::math::frechet_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the frechet log cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../db/da3/opencl_2prim_2frechet__lcdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../db/da3/opencl_2prim_2frechet__lcdf_8hpp_source.html">frechet_lcdf.hpp</a>.</p>

</div>
</div>
<a id="ga40919e3150ee05b80682f46cde802c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40919e3150ee05b80682f46cde802c22">&#9670;&nbsp;</a></span>frechet_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_shape_cl, T_scale_cl&gt; stan::math::frechet_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of the frechet density for the specified scalar(s) given the specified sample stan::math::size(s). y, alpha, or sigma can each either be scalar or a vector on OpenCL device. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/alpha/sigma triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of shape </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>shape </td></tr>
    <tr><td class="paramname">sigma</td><td>scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/dc6/opencl_2prim_2frechet__lpdf_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../d9/dc6/opencl_2prim_2frechet__lpdf_8hpp_source.html">frechet_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga27e938e6fdd621c5903cc37401c54909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27e938e6fdd621c5903cc37401c54909">&#9670;&nbsp;</a></span>from_eigen_uplo_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> stan::math::from_eigen_uplo_type </td>
          <td>(</td>
          <td class="paramtype">Eigen::UpLoType&#160;</td>
          <td class="paramname"><em>eigen_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a view from <code>Eigen::UpLoType</code>. <code>Eigen::Lower</code>, <code>Eigen::StrictlyLower</code> and <code>Eigen::UnitLower</code> become <code>PartialViewCL::Lower</code>. Similar for <code>Upper</code>. Any other view becomes <code>PartialViewCL::Entire</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eigen_type</td><td><code>UpLoType</code> to create a view from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00086">86</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="ga44e84cc75a88ea72d01c090997fdc556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44e84cc75a88ea72d01c090997fdc556">&#9670;&nbsp;</a></span>from_matrix_cl() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_dst , typename T , require_arithmetic_t&lt; T &gt; *  = nullptr, require_same_t&lt; T_dst, T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_dst stan::math::from_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy A 1 by 1 source matrix from the Device to the host. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An arithmetic type to pass the value from the OpenCL matrix to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A 1x1 matrix on the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dst Arithmetic to receive the <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> value.</dd></dl>
<p>Copies the source matrix that is stored on the OpenCL device to the destination <code>std::vector</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_dst</td><td>destination type </td></tr>
    <tr><td class="paramname">T</td><td>scalar in the source matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source matrix on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::vector</code> with a copy of the data in the source matrix</dd></dl>
<p>Copies the source matrix that is stored on the OpenCL device to the destination <code>std::vector</code> containing <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> vectors.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_dst</td><td>destination type </td></tr>
    <tr><td class="paramname">T</td><td>scalar in the source matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source matrix on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::vector</code> containing <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> vectors with a copy of the data in the source matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00145">145</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="gadf2a61125c6dca5e5a400d56e24cc6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf2a61125c6dca5e5a400d56e24cc6d5">&#9670;&nbsp;</a></span>from_matrix_cl() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_ret , typename T , require_eigen_t&lt; T_ret &gt; *  = nullptr, require_matrix_cl_t&lt; T &gt; *  = nullptr, require_st_same&lt; T_ret, T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::from_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the source matrix that is stored on the OpenCL device to the destination <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_ret</td><td>destination type </td></tr>
    <tr><td class="paramname">T</td><td>scalar in the source matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source matrix on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix with a copy of the data in the source matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00061">61</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="gad35b73b8bb6ac116683220a20f4c317d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad35b73b8bb6ac116683220a20f4c317d">&#9670;&nbsp;</a></span>from_matrix_cl() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_ret , typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr, require_not_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::from_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies result of a kernel generator expression to the specified destination type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_ret</td><td>destination type </td></tr>
    <tr><td class="paramname">T</td><td>type of expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix with a copy of the data in the source matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00133">133</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga1f99f6ae3dd35f205631e839119f5541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f99f6ae3dd35f205631e839119f5541">&#9670;&nbsp;</a></span>from_matrix_cl() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::from_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the source kernel generator expression or matrix that is stored on the OpenCL device to the destination <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>source type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>expression or source matrix on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix with a copy of the data in the source matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00229">229</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="gaedf3e76a11e9efeae4a1215bfb67c8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedf3e76a11e9efeae4a1215bfb67c8be">&#9670;&nbsp;</a></span>from_matrix_cl() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_dst , typename T , require_var_vt&lt; is_eigen, T_dst &gt; *  = nullptr, require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_dst stan::math::from_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the source var that has data stored on the OpenCL device to destination var containing <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_dst</td><td>destination type </td></tr>
    <tr><td class="paramname">T</td><td>type of the matrix or expression on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>source <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> or expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>var with a copy of the data on the host</dd></dl>
<p>Copies the source var that has data stored on the OpenCL device to destination <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix containing vars.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_dst</td><td>destination type </td></tr>
    <tr><td class="paramname">T</td><td>type of the matrix or expression on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>source <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> or expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>var with a copy of the data on the host </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html#l00118">118</a> of file <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga016b4e7e4fd48ee3333c5c37507e3d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga016b4e7e4fd48ee3333c5c37507e3d01">&#9670;&nbsp;</a></span>from_matrix_cl() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_dst , typename T , require_std_vector_vt&lt; is_var, T_dst &gt; *  = nullptr, require_all_stan_scalar_t&lt; value_type_t&lt; T_dst &gt;&gt; *  = nullptr, require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_dst stan::math::from_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the source var that has data stored on the OpenCL device to destination <code>std::vector</code> containing vars.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_dst</td><td>destination type </td></tr>
    <tr><td class="paramname">T</td><td>type of the matrix or expression on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>source <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> or expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>var with a copy of the data on the host</dd></dl>
<p>Copies the source var that has data stored on the OpenCL device to destination std::vector containing either <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> vectors of vars or vars containing <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> vectors.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_dst</td><td>destination type </td></tr>
    <tr><td class="paramname">T</td><td>type of the matrix or expression on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>source <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> or expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>var with a copy of the data on the host </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html#l00159">159</a> of file <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="gaeefdbbf87e96786f8460982c80c5c06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeefdbbf87e96786f8460982c80c5c06f">&#9670;&nbsp;</a></span>from_matrix_cl() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::from_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the source var that has data stored on the OpenCL device to destination <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix containing vars.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the matrix or expression on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> or expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>var with a copy of the data on the host </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html#l00209">209</a> of file <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga3964605bbb452f539ad82458a1a7cc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3964605bbb452f539ad82458a1a7cc07">&#9670;&nbsp;</a></span>gamma_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_shape_cl, T_inv_scale_cl&gt; stan::math::gamma_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of a gamma density for y with the specified shape and inverse scale parameters. Shape and inverse scale parameters must be greater than 0. y must be greater than or equal to 0.</p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{Gamma}}(\alpha, \beta) \\ \log (p (y \, |\, \alpha, \beta) ) &amp;=&amp; \log \left( \frac{\beta^\alpha}{\Gamma(\alpha)} y^{\alpha - 1} \exp^{- \beta y} \right) \\ &amp;=&amp; \alpha \log(\beta) - \log(\Gamma(\alpha)) + (\alpha - 1) \log(y) - \beta y\\ &amp; &amp; \mathrm{where} \; y &gt; 0 \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of shape </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">alpha</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">beta</td><td>Inverse scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if alpha is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if beta is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d44/opencl_2prim_2gamma__lpdf_8hpp_source.html#l00047">47</a> of file <a class="el" href="../../df/d44/opencl_2prim_2gamma__lpdf_8hpp_source.html">gamma_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga7ae66d06eb626b8357a5fc74289bfe42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ae66d06eb626b8357a5fc74289bfe42">&#9670;&nbsp;</a></span>gp_dot_prod_cov() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , typename T_sigma , require_all_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr, require_stan_scalar_t&lt; T_sigma &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::gp_dot_prod_cov </td>
          <td>(</td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_sigma&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dot product kernel on the GPU.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of sigma </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dot product covariance matrix that is positive semi-definite </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d83/opencl_2prim_2gp__dot__prod__cov_8hpp_source.html#l00027">27</a> of file <a class="el" href="../../d9/d83/opencl_2prim_2gp__dot__prod__cov_8hpp_source.html">gp_dot_prod_cov.hpp</a>.</p>

</div>
</div>
<a id="gadfb569d6717740727352a2b67d23adfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfb569d6717740727352a2b67d23adfc">&#9670;&nbsp;</a></span>gp_dot_prod_cov() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , typename T_y , typename T_sigma , require_all_prim_or_rev_kernel_expression_t&lt; T_x, T_y &gt; *  = nullptr, require_stan_scalar_t&lt; T_sigma &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::gp_dot_prod_cov </td>
          <td>(</td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_sigma&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dot product kernel on the GPU.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of sigma </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dot product covariance matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d83/opencl_2prim_2gp__dot__prod__cov_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d9/d83/opencl_2prim_2gp__dot__prod__cov_8hpp_source.html">gp_dot_prod_cov.hpp</a>.</p>

</div>
</div>
<a id="ga9ebc1c13865b66015a0f30739b18b28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ebc1c13865b66015a0f30739b18b28f">&#9670;&nbsp;</a></span>gp_exp_quad_cov() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename  = require_all_arithmetic_t&lt;T1, T2, T3, T4&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T1, T2, T3, T4&gt; &gt; stan::math::gp_exp_quad_cov </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4&#160;</td>
          <td class="paramname"><em>length_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Squared exponential kernel on the GPU.</p>
<p>This function is for the cross covariance matrix needed to compute the posterior predictive density.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the second matrix </td></tr>
    <tr><td class="paramname">T3</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T4</td><td>Type of length scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first input vector or matrix </td></tr>
    <tr><td class="paramname">y</td><td>second input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Squared distance between elements of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/dcc/opencl_2prim_2gp__exp__quad__cov_8hpp_source.html#l00060">60</a> of file <a class="el" href="../../d9/dcc/opencl_2prim_2gp__exp__quad__cov_8hpp_source.html">gp_exp_quad_cov.hpp</a>.</p>

</div>
</div>
<a id="gaa686087fcae5e7016b355ceb3cf45846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa686087fcae5e7016b355ceb3cf45846">&#9670;&nbsp;</a></span>gp_exp_quad_cov() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename  = require_all_arithmetic_t&lt;T1, T2, T3&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T1, T2, T3&gt; &gt; stan::math::gp_exp_quad_cov </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3&#160;</td>
          <td class="paramname"><em>length_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Squared exponential kernel on the GPU.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T3</td><td>Type of length_scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Squared distance between elements of x. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/dcc/opencl_2prim_2gp__exp__quad__cov_8hpp_source.html#l00028">28</a> of file <a class="el" href="../../d9/dcc/opencl_2prim_2gp__exp__quad__cov_8hpp_source.html">gp_exp_quad_cov.hpp</a>.</p>

</div>
</div>
<a id="ga63ac2500cbe6777efe781d2738148ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63ac2500cbe6777efe781d2738148ed4">&#9670;&nbsp;</a></span>gp_exponential_cov() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr, require_all_arithmetic_t&lt; T3, T4 &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt; stan::math::gp_exponential_cov </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4&#160;</td>
          <td class="paramname"><em>length_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matern exponential kernel on the GPU.</p>
<p>This function is for the cross covariance matrix needed to compute the posterior predictive density.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the second matrix </td></tr>
    <tr><td class="paramname">T3</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T4</td><td>Type of length scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first input vector or matrix </td></tr>
    <tr><td class="paramname">y</td><td>second input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dot product covariance matrix</dd></dl>
<p>Squared exponential kernel on the GPU.</p>
<p>This function is for the cross covariance matrix needed to compute the posterior predictive density.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the second matrix </td></tr>
    <tr><td class="paramname">T3</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T4</td><td>Type of length scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first input vector or matrix </td></tr>
    <tr><td class="paramname">y</td><td>second input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Squared distance between elements of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/d20/opencl_2prim_2gp__exponential__cov_8hpp_source.html#l00067">67</a> of file <a class="el" href="../../d3/d20/opencl_2prim_2gp__exponential__cov_8hpp_source.html">gp_exponential_cov.hpp</a>.</p>

</div>
</div>
<a id="gac47f7d0f97a1035236ac74de3b965020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac47f7d0f97a1035236ac74de3b965020">&#9670;&nbsp;</a></span>gp_exponential_cov() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , require_all_kernel_expressions_and_none_scalar_t&lt; T1 &gt; *  = nullptr, require_all_arithmetic_t&lt; T2, T3 &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt; stan::math::gp_exponential_cov </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3&#160;</td>
          <td class="paramname"><em>length_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matern exponential kernel on the GPU.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T3</td><td>Type of length_scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dot product covariance matrix that is positive semi-definite</dd></dl>
<p>Squared exponential kernel on the GPU.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T3</td><td>Type of length_scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Squared distance between elements of x. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/d20/opencl_2prim_2gp__exponential__cov_8hpp_source.html#l00029">29</a> of file <a class="el" href="../../d3/d20/opencl_2prim_2gp__exponential__cov_8hpp_source.html">gp_exponential_cov.hpp</a>.</p>

</div>
</div>
<a id="ga85aa537a04d32939114f7dd8b75fdc5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85aa537a04d32939114f7dd8b75fdc5b">&#9670;&nbsp;</a></span>gp_matern32_cov() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr, require_all_arithmetic_t&lt; T3, T4 &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt; stan::math::gp_matern32_cov </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4&#160;</td>
          <td class="paramname"><em>length_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matern 3/2 kernel on the GPU.</p>
<p>This function is for the cross covariance matrix needed to compute the posterior predictive density.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the second matrix </td></tr>
    <tr><td class="paramname">T3</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T4</td><td>Type of length scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first input vector or matrix </td></tr>
    <tr><td class="paramname">y</td><td>second input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matern 3/2 covariance matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d8d/opencl_2prim_2gp__matern32__cov_8hpp_source.html#l00067">67</a> of file <a class="el" href="../../d6/d8d/opencl_2prim_2gp__matern32__cov_8hpp_source.html">gp_matern32_cov.hpp</a>.</p>

</div>
</div>
<a id="ga42d71e19927c390c7e2ca70ffe71d600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42d71e19927c390c7e2ca70ffe71d600">&#9670;&nbsp;</a></span>gp_matern32_cov() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , require_all_kernel_expressions_and_none_scalar_t&lt; T1 &gt; *  = nullptr, require_all_arithmetic_t&lt; T2, T3 &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt; stan::math::gp_matern32_cov </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3&#160;</td>
          <td class="paramname"><em>length_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matern 3/2 kernel on the GPU.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T3</td><td>Type of length_scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matern 3/2 covariance matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d8d/opencl_2prim_2gp__matern32__cov_8hpp_source.html#l00029">29</a> of file <a class="el" href="../../d6/d8d/opencl_2prim_2gp__matern32__cov_8hpp_source.html">gp_matern32_cov.hpp</a>.</p>

</div>
</div>
<a id="ga07fab169578cad9bff602bc9c60453a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07fab169578cad9bff602bc9c60453a7">&#9670;&nbsp;</a></span>gp_matern52_cov() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr, require_all_arithmetic_t&lt; T3, T4 &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt; stan::math::gp_matern52_cov </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4&#160;</td>
          <td class="paramname"><em>length_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matern 5/2 kernel on the GPU.</p>
<p>This function is for the cross covariance matrix needed to compute the posterior predictive density.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the second matrix </td></tr>
    <tr><td class="paramname">T3</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T4</td><td>Type of length scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first input vector or matrix </td></tr>
    <tr><td class="paramname">y</td><td>second input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matern 5/2 covariance matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/df9/opencl_2prim_2gp__matern52__cov_8hpp_source.html#l00068">68</a> of file <a class="el" href="../../d8/df9/opencl_2prim_2gp__matern52__cov_8hpp_source.html">gp_matern52_cov.hpp</a>.</p>

</div>
</div>
<a id="gaea5e4b95241432025c0dbf5693659fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea5e4b95241432025c0dbf5693659fda">&#9670;&nbsp;</a></span>gp_matern52_cov() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , require_all_kernel_expressions_and_none_scalar_t&lt; T1 &gt; *  = nullptr, require_all_arithmetic_t&lt; T2, T3 &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt; stan::math::gp_matern52_cov </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3&#160;</td>
          <td class="paramname"><em>length_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matern 5/2 kernel on the GPU.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T3</td><td>Type of length_scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matern 5/2 covariance matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/df9/opencl_2prim_2gp__matern52__cov_8hpp_source.html#l00029">29</a> of file <a class="el" href="../../d8/df9/opencl_2prim_2gp__matern52__cov_8hpp_source.html">gp_matern52_cov.hpp</a>.</p>

</div>
</div>
<a id="ga2b361cf5a03a7fd55cf5ab3b3d1c285d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b361cf5a03a7fd55cf5ab3b3d1c285d">&#9670;&nbsp;</a></span>gumbel_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::gumbel_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the gumbel cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">beta</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d1/df2/opencl_2prim_2gumbel__cdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../d1/df2/opencl_2prim_2gumbel__cdf_8hpp_source.html">gumbel_cdf.hpp</a>.</p>

</div>
</div>
<a id="ga9dded1ca1056f57bf752bccda74ae6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dded1ca1056f57bf752bccda74ae6b0">&#9670;&nbsp;</a></span>gumbel_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::gumbel_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Gumbel log complementary cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">beta</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of log complementary cumulative probabilities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d8c/opencl_2prim_2gumbel__lccdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../de/d8c/opencl_2prim_2gumbel__lccdf_8hpp_source.html">gumbel_lccdf.hpp</a>.</p>

</div>
</div>
<a id="gabf55abc2c3182268292a063a51c87b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf55abc2c3182268292a063a51c87b6b">&#9670;&nbsp;</a></span>gumbel_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::gumbel_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Gumbel log complementary cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">beta</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of log complementary cumulative probabilities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/da0/opencl_2prim_2gumbel__lcdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../d2/da0/opencl_2prim_2gumbel__lcdf_8hpp_source.html">gumbel_lcdf.hpp</a>.</p>

</div>
</div>
<a id="gaa88407c66c8c8de7bf26c1d8eadaff84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa88407c66c8c8de7bf26c1d8eadaff84">&#9670;&nbsp;</a></span>gumbel_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::gumbel_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Gumbel log probability density for the given location and scale. Given containers of matching sizes, returns the log sum of densities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of real parameter </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>real parameter </td></tr>
    <tr><td class="paramname">mu</td><td>location parameter </td></tr>
    <tr><td class="paramname">beta</td><td>scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability density or log sum of probability densities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is nan, mu is infinite, or beta is nonpositive </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d3/d6f/opencl_2prim_2gumbel__lpdf_8hpp_source.html#l00036">36</a> of file <a class="el" href="../../d3/d6f/opencl_2prim_2gumbel__lpdf_8hpp_source.html">gumbel_lpdf.hpp</a>.</p>

</div>
</div>
<a id="gac32df5b5541df60cd45e329bf067f000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac32df5b5541df60cd45e329bf067f000">&#9670;&nbsp;</a></span>inv_chi_square_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_dof_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_dof_cl&gt; stan::math::inv_chi_square_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof_cl &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of an inverse chi-squared density for y with the specified degrees of freedom parameter. The degrees of freedom parameter must be greater than 0. y must be greater than 0.</p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{Inv-}}\chi^2_\nu \\ \log (p (y \, |\, \nu)) &amp;=&amp; \log \left( \frac{2^{-\nu / 2}}{\Gamma (\nu / 2)} y^{- (\nu / 2 + 1)} \exp^{-1 / (2y)} \right) \\ &amp;=&amp; - \frac{\nu}{2} \log(2) - \log (\Gamma (\nu / 2)) - (\frac{\nu}{2} + 1) \log(y) - \frac{1}{2y} \\ &amp; &amp; \mathrm{ where } \; y &gt; 0 \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_dof_cl</td><td>type of degrees of freedom </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than or equal to 0 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dc/db7/opencl_2prim_2inv__chi__square__lpdf_8hpp_source.html#l00044">44</a> of file <a class="el" href="../../dc/db7/opencl_2prim_2inv__chi__square__lpdf_8hpp_source.html">inv_chi_square_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga7e0332105689b4e9992e99166c4f3e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e0332105689b4e9992e99166c4f3e12">&#9670;&nbsp;</a></span>inv_gamma_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_shape_cl, T_scale_cl&gt; stan::math::inv_gamma_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of an inverse gamma density for y with the specified shape and scale parameters. Shape and scale parameters must be greater than 0. y must be greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">alpha</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">beta</td><td>Scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if alpha is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if beta is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_shape</td><td>Type of shape. </td></tr>
    <tr><td class="paramname">T_scale</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d2a/opencl_2prim_2inv__gamma__lpdf_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../da/d2a/opencl_2prim_2inv__gamma__lpdf_8hpp_source.html">inv_gamma_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga747f014e58d824281b725a7d4868dd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga747f014e58d824281b725a7d4868dd77">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> stan::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverts a view. Parts that are zero in the input become nonzero in output and vice versa. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>view to invert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inverted view </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00071">71</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="gae089d318dec46d3eecab353ccedd07ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae089d318dec46d3eecab353ccedd07ab">&#9670;&nbsp;</a></span>logistic_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::logistic_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the logistic cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dd4/opencl_2prim_2logistic__cdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../d4/dd4/opencl_2prim_2logistic__cdf_8hpp_source.html">logistic_cdf.hpp</a>.</p>

</div>
</div>
<a id="ga11e1cb21d2e8927cf2458ea675ec832c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e1cb21d2e8927cf2458ea675ec832c">&#9670;&nbsp;</a></span>logistic_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::logistic_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the logistic cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d9f/opencl_2prim_2logistic__lccdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../de/d9f/opencl_2prim_2logistic__lccdf_8hpp_source.html">logistic_lccdf.hpp</a>.</p>

</div>
</div>
<a id="ga790f7ff43cded1271978779ae5bc5f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga790f7ff43cded1271978779ae5bc5f8b">&#9670;&nbsp;</a></span>logistic_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::logistic_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the logistic cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/d40/opencl_2prim_2logistic__lcdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../dd/d40/opencl_2prim_2logistic__lcdf_8hpp_source.html">logistic_lcdf.hpp</a>.</p>

</div>
</div>
<a id="ga9aa767c6b4a5636db46932992cae075b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9aa767c6b4a5636db46932992cae075b">&#9670;&nbsp;</a></span>logistic_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::logistic_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of a logistic density for y with the specified location and scale parameters. Shape and scale parameters must be greater than 0. y must be greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">mu</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">sigma</td><td>Scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if mu is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if sigma is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>Type of shape. </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d6/de7/opencl_2prim_2logistic__lpdf_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../d6/de7/opencl_2prim_2logistic__lpdf_8hpp_source.html">logistic_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga69167b3ae3de102c803fa7b227e9d11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69167b3ae3de102c803fa7b227e9d11f">&#9670;&nbsp;</a></span>lognormal_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::lognormal_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the loghormal cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/d24/opencl_2prim_2lognormal__cdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../dd/d24/opencl_2prim_2lognormal__cdf_8hpp_source.html">lognormal_cdf.hpp</a>.</p>

</div>
</div>
<a id="ga2383f947a55d9b0ef8104fc6c84a83ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2383f947a55d9b0ef8104fc6c84a83ad">&#9670;&nbsp;</a></span>lognormal_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::lognormal_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the lognormal log complementary cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the log sum of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d3f/opencl_2prim_2lognormal__lccdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../da/d3f/opencl_2prim_2lognormal__lccdf_8hpp_source.html">lognormal_lccdf.hpp</a>.</p>

</div>
</div>
<a id="ga9495fcb0a2a223bbf0219e7805bbc487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9495fcb0a2a223bbf0219e7805bbc487">&#9670;&nbsp;</a></span>lognormal_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::lognormal_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the lognormal log cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the log sum of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/d74/opencl_2prim_2lognormal__lcdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../d4/d74/opencl_2prim_2lognormal__lcdf_8hpp_source.html">lognormal_lcdf.hpp</a>.</p>

</div>
</div>
<a id="gae14854b2ed4e8eed637cdeb8f8d15dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae14854b2ed4e8eed637cdeb8f8d15dbb">&#9670;&nbsp;</a></span>lognormal_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::lognormal_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of the lognormal density for the specified scalar(s) given the specified sample stan::math::size(s). y, mu, or sigma can each either be scalar or a vector on OpenCL device. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mu/sigma triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of prior scale for successes </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of prior scale for failures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) prior sample stan::math::size(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) prior sample stan::math::size(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d41/opencl_2prim_2lognormal__lpdf_8hpp_source.html#l00040">40</a> of file <a class="el" href="../../dc/d41/opencl_2prim_2lognormal__lpdf_8hpp_source.html">lognormal_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga3dbda02859731a08444a98d74777f846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dbda02859731a08444a98d74777f846">&#9670;&nbsp;</a></span>multi_normal_cholesky_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_covar_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_covar_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_covar_cl&gt; stan::math::multi_normal_cholesky_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar_cl &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The log of the multivariate normal density for the given y, mu, and a Cholesky factor L of the variance matrix. Sigma = LL', a square, semi-positive definite matrix.</p>
<p>Analytic expressions taken from <a href="http://qwone.com/~jason/writing/multivariateNormal.pdf">http://qwone.com/~jason/writing/multivariateNormal.pdf</a> written by Jason D. M. Rennie.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar vector </td></tr>
    <tr><td class="paramname">mu</td><td>The mean vector of the multivariate normal distribution. </td></tr>
    <tr><td class="paramname">L</td><td>The Cholesky decomposition of a variance matrix of the multivariate normal distribution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the multivariate normal density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if LL' is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_loc</td><td>Type of location. </td></tr>
    <tr><td class="paramname">T_covar</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d6/d16/opencl_2prim_2multi__normal__cholesky__lpdf_8hpp_source.html#l00042">42</a> of file <a class="el" href="../../d6/d16/opencl_2prim_2multi__normal__cholesky__lpdf_8hpp_source.html">multi_normal_cholesky_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga6ed19f70ae3520d9ef8c982dace013e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ed19f70ae3520d9ef8c982dace013e8">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T1, T2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T1, T2&gt; &gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the product of the specified matrices with the option of specifying the triangularity of either input matrices.</p>
<p>Computes the matrix multiplication C[M, K] = A[M, N] x B[N, K]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first matrix </td></tr>
    <tr><td class="paramname">B</td><td>second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">partial_view_A</td><td>specifies whether the matrix A is a lower/upper triangular or a rectangular matrix </td></tr>
    <tr><td class="paramname">partial_view_B</td><td>specifies whether the matrix B is a lower/upper triangular or a rectangular matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the first and second matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the number of columns in A and rows in B do not match </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/d62/opencl_2prim_2multiply_8hpp_source.html#l00038">38</a> of file <a class="el" href="../../d4/d62/opencl_2prim_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a id="ga72e3539ba6e81a0a69e69f09c683252a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72e3539ba6e81a0a69e69f09c683252a">&#9670;&nbsp;</a></span>multiply_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;T&gt; stan::math::multiply_transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the product of a square OpenCL matrix with its transpose.</p>
<p>Computes the matrix multiplication C = A x A^T</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the input matrix and its transpose </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d28/multiply__transpose_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../d7/d28/multiply__transpose_8hpp_source.html">multiply_transpose.hpp</a>.</p>

</div>
</div>
<a id="gacb16f794da8d9e6341f2543fbab56237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb16f794da8d9e6341f2543fbab56237">&#9670;&nbsp;</a></span>neg_binomial_2_log_glm_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_phi_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_x_cl, T_alpha_cl, T_beta_cl, T_phi_cl&gt; stan::math::neg_binomial_2_log_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x_cl &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_phi_cl &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PMF of the Generalized Linear Model (GLM) with Negative-Binomial-2 distribution and log link function. The idea is that neg_binomial_2_log_glm_lpmf(y, x, alpha, beta, phi) should compute a more efficient version of neg_binomial_2_log_lpmf(y, alpha + x * beta, phi) by using analytically simplified gradients. If containers are supplied, returns the log sum of the probabilities. This is an overload of the GLM in prim/prob/neg_binomial_2_log_glm_lpdf.hpp that is implemented in OpenCL. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of independent variable; this can be a <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> vector of intercepts or a single value (wich will be broadcast - used for all instances); </td></tr>
    <tr><td class="paramname">T_x_cl</td><td>type of the design matrix </td></tr>
    <tr><td class="paramname">T_alpha_cl</td><td>type of the intercept(s); this can be a vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta_cl</td><td>type of the weight vector; this can also be a scalar; </td></tr>
    <tr><td class="paramname">T_phi_cl</td><td>type of the (positive) precision(s); this can be a vector (of the same length as y, for heteroskedasticity) or a scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>failures count scalar or vector parameter on OpenCL device. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
    <tr><td class="paramname">phi</td><td>(vector of) precision parameter(s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if phi is infinite or non-positive. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is negative. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/def/opencl_2prim_2neg__binomial__2__log__glm__lpmf_8hpp_source.html#l00069">69</a> of file <a class="el" href="../../d5/def/opencl_2prim_2neg__binomial__2__log__glm__lpmf_8hpp_source.html">neg_binomial_2_log_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga7c1c0e8c6edb035b297e73193f8cd820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c1c0e8c6edb035b297e73193f8cd820">&#9670;&nbsp;</a></span>neg_binomial_2_log_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_log_location_cl , typename T_precision_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_n_cl, T_log_location_cl, T_precision_cl&gt; stan::math::neg_binomial_2_log_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_log_location_cl &amp;&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision_cl &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The log of the log transformed negative binomial density for the specified scalars given the specified mean(s) and deviation(s). n, eta, or phi can each be either a scalar or a vector <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mean/deviation triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_log_location_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_precision_cl</td><td>type of precision parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">eta</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">phi</td><td>(Sequence of) precision parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of the densities. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/dc2/opencl_2prim_2neg__binomial__2__log__lpmf_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../de/dc2/opencl_2prim_2neg__binomial__2__log__lpmf_8hpp_source.html">neg_binomial_2_log_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga0f3956bcf1b6e3aac673b7b89f2f9b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f3956bcf1b6e3aac673b7b89f2f9b4d">&#9670;&nbsp;</a></span>neg_binomial_2_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_location_cl , typename T_precision_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_n_cl, T_location_cl, T_precision_cl&gt; stan::math::neg_binomial_2_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_location_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision_cl &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The log of the negative binomial density for the specified scalars given the specified mean(s) and deviation(s). n, mu, or phi can each be either a scalar or a vector <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mean/deviation triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_location_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_precision_cl</td><td>type of precision parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">phi</td><td>(Sequence of) precision parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of the densities. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../db/dfc/opencl_2prim_2neg__binomial__2__lpmf_8hpp_source.html#l00042">42</a> of file <a class="el" href="../../db/dfc/opencl_2prim_2neg__binomial__2__lpmf_8hpp_source.html">neg_binomial_2_lpmf.hpp</a>.</p>

</div>
</div>
<a id="gaacb77966b5ca780cac193dfeb6e7dc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacb77966b5ca780cac193dfeb6e7dc7f">&#9670;&nbsp;</a></span>neg_binomial_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_shape_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_n_cl, T_shape_cl, T_inv_scale_cl&gt; stan::math::neg_binomial_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The log of the negative binomial density for the specified scalars given the specified mean(s) and deviation(s). n, alpha, or beta can each be either a scalar or a vector <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mean/deviation triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of precision parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">beta</td><td>(Sequence of) precision parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of the densities. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d1/d45/opencl_2prim_2neg__binomial__lpmf_8hpp_source.html#l00040">40</a> of file <a class="el" href="../../d1/d45/opencl_2prim_2neg__binomial__lpmf_8hpp_source.html">neg_binomial_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga5778a9ae4790a5fe723a4d963f721df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5778a9ae4790a5fe723a4d963f721df0">&#9670;&nbsp;</a></span>normal_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::normal_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the normal cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d3d/opencl_2prim_2normal__cdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../da/d3d/opencl_2prim_2normal__cdf_8hpp_source.html">normal_cdf.hpp</a>.</p>

</div>
</div>
<a id="gaf3c799735f974356f8d1ab7743960a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3c799735f974356f8d1ab7743960a65">&#9670;&nbsp;</a></span>normal_id_glm_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_sigma_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl, T_sigma_cl&gt; stan::math::normal_id_glm_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x_cl &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_sigma_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PDF of the Generalized Linear Model (GLM) with Normal distribution and id link function. If containers are supplied, returns the log sum of the probabilities. This is an overload of the GLM in <a class="el" href="../../de/d31/prim_2prob_2normal__id__glm__lpdf_8hpp.html">prim/prob/normal_id_glm_lpdf.hpp</a> that is implemented in OpenCL. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of independent variable; this can be a <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> vector of intercepts or a single value (wich will be broadcast - used for all instances); </td></tr>
    <tr><td class="paramname">T_x_cl</td><td>type of the design matrix </td></tr>
    <tr><td class="paramname">T_alpha_cl</td><td>type of the intercept(s); this can be a (optionally <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a></code> containing) <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> column vector (of the same length as y) of intercepts or a scalar (for models with constant intercept) </td></tr>
    <tr><td class="paramname">T_beta_cl</td><td>type of the weight vector; (optionally <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a></code> containing) <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> column vector </td></tr>
    <tr><td class="paramname">T_sigma_cl</td><td>type of the (positive) scale(s); (optionally <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a></code> containing) <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> column vector (of the same length as y, for heteroskedasticity) or a scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>scalar or vector parameter on OpenCL device. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale parameters for the normal distribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d1/dc0/opencl_2prim_2normal__id__glm__lpdf_8hpp_source.html#l00063">63</a> of file <a class="el" href="../../d1/dc0/opencl_2prim_2normal__id__glm__lpdf_8hpp_source.html">normal_id_glm_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga4ffb7c87522de6e24c7c95fa71b2e116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ffb7c87522de6e24c7c95fa71b2e116">&#9670;&nbsp;</a></span>normal_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::normal_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the normal log complementary cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the log sum of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/d57/opencl_2prim_2normal__lccdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../d3/d57/opencl_2prim_2normal__lccdf_8hpp_source.html">normal_lccdf.hpp</a>.</p>

</div>
</div>
<a id="gaa7b2d28bf1c40f0f9ec609d73f1011b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7b2d28bf1c40f0f9ec609d73f1011b2">&#9670;&nbsp;</a></span>normal_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::normal_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the normal log complementary cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the log sum of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/dcb/opencl_2prim_2normal__lcdf_8hpp_source.html#l00180">180</a> of file <a class="el" href="../../dd/dcb/opencl_2prim_2normal__lcdf_8hpp_source.html">normal_lcdf.hpp</a>.</p>

</div>
</div>
<a id="gab98a15165135ddb986e4f74cb66817ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab98a15165135ddb986e4f74cb66817ba">&#9670;&nbsp;</a></span>normal_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::normal_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The log of the normal density for the specified scalar(s) given the specified mean(s) and deviation(s). y, mu, or sigma can each be either a scalar or a vector <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mean/deviation triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location parameter(s) for the normal distribution. </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale parameters for the normal distribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of the densities. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dd/d2f/opencl_2prim_2normal__lpdf_8hpp_source.html#l00040">40</a> of file <a class="el" href="../../dd/d2f/opencl_2prim_2normal__lpdf_8hpp_source.html">normal_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga363eead878eb45fb01517e94ac7d4f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga363eead878eb45fb01517e94ac7d4f4b">&#9670;&nbsp;</a></span>ordered_logistic_glm_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_beta , typename T_cuts , require_all_prim_or_rev_kernel_expression_t&lt; T_y, T_x, T_beta, T_cuts &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_x, T_beta, T_cuts&gt; stan::math::ordered_logistic_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_cuts &amp;&#160;</td>
          <td class="paramname"><em>cuts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PMF of the ordinal regression Generalized Linear Model (GLM). This is equivalent to and faster than ordered_logistic_lpmf(y, x * beta, cuts). This is an overload of the GLM in <a class="el" href="../../da/d4f/prim_2prob_2ordered__logistic__glm__lpmf_8hpp.html">prim/prob/ordered_logistic_glm_lpmf.hpp</a> that is implemented in OpenCL.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_beta</td><td>type the vector of weights </td></tr>
    <tr><td class="paramname">T_cuts</td><td>type the vector of cutpoints </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>a scalar or vector of classes on OpenCL device. If it is a scalar it will be broadcast - used for all instances. Values should be between 1 and number of classes, including endpoints. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix or row vector on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
    <tr><td class="paramname">cuts</td><td>cutpoints vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If any class is not between 1 and the number of cutpoints plus 2 or if the cutpoint vector is not sorted in ascending order or any input is not finite </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d9/dbc/opencl_2prim_2ordered__logistic__glm__lpmf_8hpp_source.html#l00052">52</a> of file <a class="el" href="../../d9/dbc/opencl_2prim_2ordered__logistic__glm__lpmf_8hpp_source.html">ordered_logistic_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a id="gaa2fa71e9871a9b2f6f720de72177c1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2fa71e9871a9b2f6f720de72177c1f3">&#9670;&nbsp;</a></span>ordered_logistic_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_cuts_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_cuts_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_cuts_cl&gt; stan::math::ordered_logistic_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_cuts_cl &amp;&#160;</td>
          <td class="paramname"><em>cuts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the (natural) log probability of the specified array of integers given the vector of continuous locations and specified cutpoints in an ordered logistic model.</p>
<p>Typically the continuous lambda will be the dot product of a vector of regression coefficients and a vector of predictors for the outcome</p>
<p class="formulaDsp">
\[ \frac{\partial }{\partial \lambda} = \begin{cases}\\ -\mathrm{logit}^{-1}(\lambda - c_1) &amp; \mbox{if } k = 1,\\ -(((1-e^{c_{k-1}-c_{k-2}})^{-1} - \mathrm{logit}^{-1}(c_{k-2}-\lambda)) + ((1-e^{c_{k-2}-c_{k-1}})^{-1} - \mathrm{logit}^{-1}(c_{k-1}-\lambda))) &amp; \mathrm{if } 1 &lt; k &lt; K, \mathrm{and}\\ \mathrm{logit}^{-1}(c_{K-2}-\lambda) &amp; \mathrm{if } k = K. \end{cases} \]
</p>
<p class="formulaDsp">
\[ \frac{\partial }{\partial \lambda} = \begin{cases} -\mathrm{logit}^{-1}(\lambda - c_1) &amp; \text{if } k = 1,\\ -(((1-e^{c_{k-1}-c_{k-2}})^{-1} - \mathrm{logit}^{-1}(c_{k-2}-\lambda)) + ((1-e^{c_{k-2}-c_{k-1}})^{-1} - \mathrm{logit}^{-1}(c_{k-1}-\lambda))) &amp; \text{if } 1 &lt; k &lt; K, \text{ and}\\ \mathrm{logit}^{-1}(c_{K-2}-\lambda) &amp; \text{if } k = K. \end{cases} \]
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>True if calculating up to a proportion. </td></tr>
    <tr><td class="paramname">T_y</td><td>Y variable type (integer or array of integers). </td></tr>
    <tr><td class="paramname">T_loc</td><td>lambda type. </td></tr>
    <tr><td class="paramname">T_cut</td><td>Cut-point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array of integers </td></tr>
    <tr><td class="paramname">lambda</td><td>Vector of continuous lambda variables. </td></tr>
    <tr><td class="paramname">cuts</td><td>Positive increasing vector of cutpoints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log probability of outcome given lambda and cutpoints. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the outcome is not between 1 and the number of cutpoints plus 2; if the cutpoint vector is empty; if the cutpoint vector contains a non-positive, non-finite value; or if the cutpoint vector is not sorted in ascending order. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If y and lambda are different lengths. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dd/db5/opencl_2prim_2ordered__logistic__lpmf_8hpp_source.html#l00070">70</a> of file <a class="el" href="../../dd/db5/opencl_2prim_2ordered__logistic__lpmf_8hpp_source.html">ordered_logistic_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga490df7651c22c9e06d09da69ad303e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga490df7651c22c9e06d09da69ad303e30">&#9670;&nbsp;</a></span>packed_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::packed_copy </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Packs the square flat triangular matrix on the OpenCL device and copies it to the std::vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the flat triangular source matrix on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packed std::vector </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not triangular </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00243">243</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="gaed1f7da1a49ff3c2a9e1147b4eef4662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed1f7da1a49ff3c2a9e1147b4eef4662">&#9670;&nbsp;</a></span>packed_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_cl_view matrix_view, typename Vec , typename Vec_scalar  = scalar_type_t&lt;Vec&gt;, require_vector_vt&lt; std::is_arithmetic, Vec &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;Vec_scalar&gt; stan::math::packed_copy </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the packed triangular matrix from the source std::vector to an OpenCL buffer and unpacks it to a flat matrix on the OpenCL device. If a lvalue is passed to this constructor the caller must make sure that it does not go out of scope before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.wait_for_write_events()</code> or <code>.wait_for_read_write_events()</code> on returned matrix or any matrix that is calculated from that one.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">matrix_view</td><td>the triangularity of the source matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the packed source std::vector </td></tr>
    <tr><td class="paramname">rows</td><td>the number of rows in the flat matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the destination flat matrix on the OpenCL device </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the size of the vector does not match the expected size for the packed triangular matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00295">295</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga99ac10a703e5d01d02700b4effea8d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ac10a703e5d01d02700b4effea8d05">&#9670;&nbsp;</a></span>pareto_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_scale_cl, T_shape_cl&gt; stan::math::pareto_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>y_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Pareto cumulative density function. Given containers of matching sizes, returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">y_min</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d11/opencl_2prim_2pareto__cdf_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../d5/d11/opencl_2prim_2pareto__cdf_8hpp_source.html">pareto_cdf.hpp</a>.</p>

</div>
</div>
<a id="gaab4792e29b438cf1e3a244d26734ec5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab4792e29b438cf1e3a244d26734ec5c">&#9670;&nbsp;</a></span>pareto_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_scale_cl, T_shape_cl&gt; stan::math::pareto_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>y_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Pareto cumulative density function. Given containers of matching sizes, returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">y_min</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dd8/opencl_2prim_2pareto__lccdf_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../d4/dd8/opencl_2prim_2pareto__lccdf_8hpp_source.html">pareto_lccdf.hpp</a>.</p>

</div>
</div>
<a id="gab314951f2c8314308e593e4c23b8d601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab314951f2c8314308e593e4c23b8d601">&#9670;&nbsp;</a></span>pareto_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_scale_cl, T_shape_cl&gt; stan::math::pareto_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>y_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Pareto cumulative density function. Given containers of matching sizes, returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">y_min</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/da5/opencl_2prim_2pareto__lcdf_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../d2/da5/opencl_2prim_2pareto__lcdf_8hpp_source.html">pareto_lcdf.hpp</a>.</p>

</div>
</div>
<a id="ga7b5e8eec1c27b30ea994f94070adc148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b5e8eec1c27b30ea994f94070adc148">&#9670;&nbsp;</a></span>pareto_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_scale_cl, T_shape_cl&gt; stan::math::pareto_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>y_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of the Cauchy density for the specified scalar(s) given the specified location parameter(s) and scale parameter(s). y, y_min, or alpha can each either be scalar a vector. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/y_min/alpha triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">y_min</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/d28/opencl_2prim_2pareto__lpdf_8hpp_source.html#l00038">38</a> of file <a class="el" href="../../dd/d28/opencl_2prim_2pareto__lpdf_8hpp_source.html">pareto_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga17f33022936713376f9d3e19daaf9430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17f33022936713376f9d3e19daaf9430">&#9670;&nbsp;</a></span>pareto_type_2_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl&gt; stan::math::pareto_type_2_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the pareto type 2 cumulative density function. Given containers of matching sizes, returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">lambda</td><td>(Sequence of) scale(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) shape(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/dd9/opencl_2prim_2pareto__type__2__cdf_8hpp_source.html#l00036">36</a> of file <a class="el" href="../../da/dd9/opencl_2prim_2pareto__type__2__cdf_8hpp_source.html">pareto_type_2_cdf.hpp</a>.</p>

</div>
</div>
<a id="ga72d34272be0ff43f1e882232ac4af9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72d34272be0ff43f1e882232ac4af9c0">&#9670;&nbsp;</a></span>pareto_type_2_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl&gt; stan::math::pareto_type_2_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the pareto type 2 log complementaty cumulative density function. Given containers of matching sizes, returns the sum of log probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">lambda</td><td>(Sequence of) scale(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) shape(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/d46/opencl_2prim_2pareto__type__2__lccdf_8hpp_source.html#l00036">36</a> of file <a class="el" href="../../dd/d46/opencl_2prim_2pareto__type__2__lccdf_8hpp_source.html">pareto_type_2_lccdf.hpp</a>.</p>

</div>
</div>
<a id="gac04043a4074079cda307e5bc219cb4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac04043a4074079cda307e5bc219cb4be">&#9670;&nbsp;</a></span>pareto_type_2_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl&gt; stan::math::pareto_type_2_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the pareto type 2 log cumulative density function. Given containers of matching sizes, returns the sum of log probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">lambda</td><td>(Sequence of) scale(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) shape(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/dbe/opencl_2prim_2pareto__type__2__lcdf_8hpp_source.html#l00036">36</a> of file <a class="el" href="../../da/dbe/opencl_2prim_2pareto__type__2__lcdf_8hpp_source.html">pareto_type_2_lcdf.hpp</a>.</p>

</div>
</div>
<a id="ga83a333811247fce0ea707ce959dffa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83a333811247fce0ea707ce959dffa38">&#9670;&nbsp;</a></span>pareto_type_2_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl&gt; stan::math::pareto_type_2_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PMF of the Pareto type 2 distribution. If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of dependent variable </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of inverse scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>dependent variable </td></tr>
    <tr><td class="paramname">mu</td><td>location </td></tr>
    <tr><td class="paramname">lambda</td><td>scale </td></tr>
    <tr><td class="paramname">alpha</td><td>inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is NaN, mu is infinite, lambda is negative or infinite or alpha is negative or infinite. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/da0/opencl_2prim_2pareto__type__2__lpdf_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../da/da0/opencl_2prim_2pareto__type__2__lpdf_8hpp_source.html">pareto_type_2_lpdf.hpp</a>.</p>

</div>
</div>
<a id="gacd6c49794202989a029ff70567f55479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd6c49794202989a029ff70567f55479">&#9670;&nbsp;</a></span>poisson_log_glm_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_x_cl, T_alpha_cl, T_beta_cl&gt; stan::math::poisson_log_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x_cl &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PMF of the Generalized Linear Model (GLM) with Poisson distribution and log link function. This is an overload of the GLM in <a class="el" href="../../d3/dd2/prim_2prob_2poisson__log__glm__lpmf_8hpp.html">prim/prob/poisson_log_glm_lpmf.hpp</a> that is implemented in OpenCL. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of independent variable; this can be a <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> vector of intercepts or a single value (wich will be broadcast - used for all instances); </td></tr>
    <tr><td class="paramname">T_x_cl</td><td>type of the design matrix </td></tr>
    <tr><td class="paramname">T_alpha_cl</td><td>type of the intercept(s); this can be a <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta_cl</td><td>type of the weight vector; this can also be a single value; </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>positive integer scalar or vector parameter on OpenCL device. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is negative. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dc/dbf/opencl_2prim_2poisson__log__glm__lpmf_8hpp_source.html#l00054">54</a> of file <a class="el" href="../../dc/dbf/opencl_2prim_2poisson__log__glm__lpmf_8hpp_source.html">poisson_log_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga5b1dba179f6258a2e07a30bdbe97255a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b1dba179f6258a2e07a30bdbe97255a">&#9670;&nbsp;</a></span>poisson_log_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_log_rate_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_log_rate_cl&gt; stan::math::poisson_log_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_log_rate_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PMF of the Poisson log distribution. If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of integer parameters </td></tr>
    <tr><td class="paramname">T_log_rate_cl</td><td>type of chance of success parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>integer parameter </td></tr>
    <tr><td class="paramname">alpha</td><td>log rate parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if alpha is not a valid probability </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d28/opencl_2prim_2poisson__log__lpmf_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../d7/d28/opencl_2prim_2poisson__log__lpmf_8hpp_source.html">poisson_log_lpmf.hpp</a>.</p>

</div>
</div>
<a id="gabfdbbaacbab1d90d71290edc806bace3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfdbbaacbab1d90d71290edc806bace3">&#9670;&nbsp;</a></span>poisson_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_rate_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_rate_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_rate_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_rate_cl&gt; stan::math::poisson_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_rate_cl &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PMF of the Poisson distribution. If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of integer parameters </td></tr>
    <tr><td class="paramname">T_rate_cl</td><td>type of chance of success parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>integer parameter </td></tr>
    <tr><td class="paramname">lambda</td><td>rate parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if lambda is not a valid probability </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d8/df5/opencl_2prim_2poisson__lpmf_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../d8/df5/opencl_2prim_2poisson__lpmf_8hpp_source.html">poisson_lpmf.hpp</a>.</p>

</div>
</div>
<a id="gab91408855ed53a17cd6f385acb2f43fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab91408855ed53a17cd6f385acb2f43fc">&#9670;&nbsp;</a></span>rayleigh_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_scale_cl&gt; stan::math::rayleigh_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Rayleigh cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d4f/opencl_2prim_2rayleigh__cdf_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../d5/d4f/opencl_2prim_2rayleigh__cdf_8hpp_source.html">rayleigh_cdf.hpp</a>.</p>

</div>
</div>
<a id="ga26d27cf0c3966c101f0ea1c271f560d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26d27cf0c3966c101f0ea1c271f560d1">&#9670;&nbsp;</a></span>rayleigh_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_scale_cl&gt; stan::math::rayleigh_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Rayleigh log complementary cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d85/opencl_2prim_2rayleigh__lccdf_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../da/d85/opencl_2prim_2rayleigh__lccdf_8hpp_source.html">rayleigh_lccdf.hpp</a>.</p>

</div>
</div>
<a id="ga1b4eb053f40231980929911c9cb2f7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b4eb053f40231980929911c9cb2f7b7">&#9670;&nbsp;</a></span>rayleigh_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_scale_cl&gt; stan::math::rayleigh_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Rayleigh log cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d65/opencl_2prim_2rayleigh__lcdf_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../d8/d65/opencl_2prim_2rayleigh__lcdf_8hpp_source.html">rayleigh_lcdf.hpp</a>.</p>

</div>
</div>
<a id="ga601d163c824e05147660da53e4099bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga601d163c824e05147660da53e4099bd9">&#9670;&nbsp;</a></span>rayleigh_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_scale_cl&gt; stan::math::rayleigh_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of an Rayleigh density for y with the specified scale parameter. y and scale parameter must be greater than 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">sigma</td><td>Inverse scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if sigma is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dc/de1/opencl_2prim_2rayleigh__lpdf_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../dc/de1/opencl_2prim_2rayleigh__lpdf_8hpp_source.html">rayleigh_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga3bbe5a508d5789497afc2cbd03f8004c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bbe5a508d5789497afc2cbd03f8004c">&#9670;&nbsp;</a></span>rep_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_any_t&lt; is_matrix_cl&lt; T &gt;, math::conjunction&lt; is_var&lt; T &gt;, is_matrix_cl&lt; value_type_t&lt; T &gt;&gt;&gt;&gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::rep_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> representing an array by replicating the input value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the input </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input value </td></tr>
    <tr><td class="paramname">n</td><td>number of elements in the result array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> with replicated value from the input matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../db/d7c/opencl_2prim_2rep__array_8hpp_source.html#l00032">32</a> of file <a class="el" href="../../db/d7c/opencl_2prim_2rep__array_8hpp_source.html">rep_array.hpp</a>.</p>

</div>
</div>
<a id="ga78f19ec991d6f0ed60695ef33003868d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78f19ec991d6f0ed60695ef33003868d">&#9670;&nbsp;</a></span>rep_matrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_arithmetic_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> by replicating the input vector or row_vector. The elements of the vector or row_vector must be of arithmetic type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of elements in the input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> (vector or row_vector) </td></tr>
    <tr><td class="paramname">m</td><td>number of rows (if x is a row_vector) or columns (if x is a vector) in the results matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result matrix with replicated rows or columns</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/df2/opencl_2prim_2rep__matrix_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../da/df2/opencl_2prim_2rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a id="ga5e2c7f71203a6ba2b93d5372ed6cf01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e2c7f71203a6ba2b93d5372ed6cf01e">&#9670;&nbsp;</a></span>rep_matrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> by replicating the given value of arithmetic type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input value </td></tr>
    <tr><td class="paramname">n</td><td>number of rows in the result matrix </td></tr>
    <tr><td class="paramname">m</td><td>number of columns in the result matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> with replicated value from the input</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/df2/opencl_2prim_2rep__matrix_8hpp_source.html#l00028">28</a> of file <a class="el" href="../../da/df2/opencl_2prim_2rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a id="gaf5c33973a4c2311bf3f9284149208417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5c33973a4c2311bf3f9284149208417">&#9670;&nbsp;</a></span>rep_matrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_ret , require_var_vt&lt; is_matrix_cl, T_ret &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt;<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;double&gt; &gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> by replicating the given value of arithmetic type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the input value </td></tr>
    <tr><td class="paramname">n</td><td>number of rows in the result matrix </td></tr>
    <tr><td class="paramname">m</td><td>number of columns in the result matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> with replicated value from the input</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/da6/opencl_2rev_2rep__matrix_8hpp_source.html#l00030">30</a> of file <a class="el" href="../../da/da6/opencl_2rev_2rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a id="ga57212223aca8e2c1999b268efacecf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57212223aca8e2c1999b268efacecf33">&#9670;&nbsp;</a></span>rep_matrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt;<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;double&gt; &gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> by replicating the input vector or row_vector. The elements of the vector or row_vector must be of arithmetic type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of elements in the input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the input <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> (vector or row_vector) </td></tr>
    <tr><td class="paramname">m</td><td>number of rows (if x is a row_vector) or columns (if x is a vector) in the results matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result matrix with replicated rows or columns</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/da6/opencl_2rev_2rep__matrix_8hpp_source.html#l00055">55</a> of file <a class="el" href="../../da/da6/opencl_2rev_2rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a id="gabbac6d303d27c8ee22511862dce6c565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbac6d303d27c8ee22511862dce6c565">&#9670;&nbsp;</a></span>rep_row_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_any_t&lt; is_matrix_cl&lt; T &gt;, math::conjunction&lt; is_var&lt; T &gt;, is_matrix_cl&lt; value_type_t&lt; T &gt;&gt;&gt;&gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::rep_row_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> representing a row vector by replicating the input value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the input </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input value </td></tr>
    <tr><td class="paramname">n</td><td>number of cols in the results row_vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> with replicated value from the input matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dd/dc5/opencl_2prim_2rep__row__vector_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../dd/dc5/opencl_2prim_2rep__row__vector_8hpp_source.html">rep_row_vector.hpp</a>.</p>

</div>
</div>
<a id="gabd9fbe441671cf2a2f88cd3e8d9b8ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd9fbe441671cf2a2f88cd3e8d9b8ca8">&#9670;&nbsp;</a></span>rep_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_any_t&lt; is_matrix_cl&lt; T &gt;, math::conjunction&lt; is_var&lt; T &gt;, is_matrix_cl&lt; value_type_t&lt; T &gt;&gt;&gt;&gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::rep_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> representing a vector by replicating the input value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the input </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input value </td></tr>
    <tr><td class="paramname">n</td><td>number of rows in the results row_vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> with replicated value from the input matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/dcd/opencl_2prim_2rep__vector_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../df/dcd/opencl_2prim_2rep__vector_8hpp_source.html">rep_vector.hpp</a>.</p>

</div>
</div>
<a id="ga80392ae5670adea53e79770aa29c816a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80392ae5670adea53e79770aa29c816a">&#9670;&nbsp;</a></span>row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::row </td>
          <td>(</td>
          <td class="paramtype">T_x &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the specified row of the specified kernel generator expression using start-at-1 indexing.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of input kernel generator expression x </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input kernel generator expression. </td></tr>
    <tr><td class="paramname">j</td><td>Row index (count from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified row of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if j is out of range. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d8f/opencl_2prim_2row_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../d8/d8f/opencl_2prim_2row_8hpp_source.html">row.hpp</a>.</p>

</div>
</div>
<a id="ga61254f29c1520f4bffe4ab4e5bbd0e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61254f29c1520f4bffe4ab4e5bbd0e0e">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::rows </td>
          <td>(</td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of rows in the specified kernel generator expression.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of input kernel generator expression x </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input kernel generator expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of rows in x </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/dd4/opencl_2prim_2rows_8hpp_source.html#l00021">21</a> of file <a class="el" href="../../de/dd4/opencl_2prim_2rows_8hpp_source.html">rows.hpp</a>.</p>

</div>
</div>
<a id="ga106d028bb360d5c31554ec3495cc41d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga106d028bb360d5c31554ec3495cc41d0">&#9670;&nbsp;</a></span>scaled_inv_chi_square_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_dof_cl, T_scale_cl&gt; stan::math::scaled_inv_chi_square_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof_cl &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The log of a scaled inverse chi-squared density for y with the specified degrees of freedom parameter and scale parameter.</p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{Inv-}}\chi^2(\nu, s^2) \\ \log (p (y \, |\, \nu, s)) &amp;=&amp; \log \left( \frac{(\nu / 2)^{\nu / 2}}{\Gamma (\nu / 2)} s^\nu y^{- (\nu / 2 + 1)} \exp^{-\nu s^2 / (2y)} \right) \\ &amp;=&amp; \frac{\nu}{2} \log(\frac{\nu}{2}) - \log (\Gamma (\nu / 2)) + \nu \log(s) - (\frac{\nu}{2} + 1) \log(y) - \frac{\nu s^2}{2y} \\ &amp; &amp; \mathrm{ where } \; y &gt; 0 \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of random variable </td></tr>
    <tr><td class="paramname">T_dof_cl</td><td>type of degrees of freedom </td></tr>
    <tr><td class="paramname">T_Scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>random variable </td></tr>
    <tr><td class="paramname">nu</td><td>degrees of freedom </td></tr>
    <tr><td class="paramname">s</td><td>Scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than 0 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if s is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d70/opencl_2prim_2scaled__inv__chi__square__lpdf_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../d5/d70/opencl_2prim_2scaled__inv__chi__square__lpdf_8hpp_source.html">scaled_inv_chi_square_lpdf.hpp</a>.</p>

</div>
</div>
<a id="gadacfcfb973fe5c0ab2dac931e50b511e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadacfcfb973fe5c0ab2dac931e50b511e">&#9670;&nbsp;</a></span>skew_double_exponential_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl&gt; stan::math::skew_double_exponential_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_skewness_cl &amp;&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the skew double exponential cumulative density function. Given containers of matching sizes, returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
    <tr><td class="paramname">T_skewness_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
    <tr><td class="paramname">tau</td><td>(Sequence of) inverse scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/dba/opencl_2prim_2skew__double__exponential__cdf_8hpp_source.html#l00037">37</a> of file <a class="el" href="../../de/dba/opencl_2prim_2skew__double__exponential__cdf_8hpp_source.html">skew_double_exponential_cdf.hpp</a>.</p>

</div>
</div>
<a id="ga36ec8f9f1a5acb9c6dc9e3640a204bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36ec8f9f1a5acb9c6dc9e3640a204bda">&#9670;&nbsp;</a></span>skew_double_exponential_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl&gt; stan::math::skew_double_exponential_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_skewness_cl &amp;&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the skew double exponential cumulative density function. Given containers of matching sizes, returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
    <tr><td class="paramname">T_skewness_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
    <tr><td class="paramname">tau</td><td>(Sequence of) inverse scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d40/opencl_2prim_2skew__double__exponential__lccdf_8hpp_source.html#l00037">37</a> of file <a class="el" href="../../d8/d40/opencl_2prim_2skew__double__exponential__lccdf_8hpp_source.html">skew_double_exponential_lccdf.hpp</a>.</p>

</div>
</div>
<a id="ga9f57073fbf4146f1b66cd5ea4336af7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f57073fbf4146f1b66cd5ea4336af7d">&#9670;&nbsp;</a></span>skew_double_exponential_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl&gt; stan::math::skew_double_exponential_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_skewness_cl &amp;&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the skew double exponential cumulative density function. Given containers of matching sizes, returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
    <tr><td class="paramname">T_skewness_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
    <tr><td class="paramname">tau</td><td>(Sequence of) inverse scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d4f/opencl_2prim_2skew__double__exponential__lcdf_8hpp_source.html#l00037">37</a> of file <a class="el" href="../../d7/d4f/opencl_2prim_2skew__double__exponential__lcdf_8hpp_source.html">skew_double_exponential_lcdf.hpp</a>.</p>

</div>
</div>
<a id="ga354bf670629966ea8ff1397c3ea6a6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga354bf670629966ea8ff1397c3ea6a6a6">&#9670;&nbsp;</a></span>skew_double_exponential_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl&gt; stan::math::skew_double_exponential_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_skewness_cl &amp;&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log PMF of the skew double exponential distribution. If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of dependent variable </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter </td></tr>
    <tr><td class="paramname">T_skewness_cl</td><td>type of inverse scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>dependent variable </td></tr>
    <tr><td class="paramname">mu</td><td>location </td></tr>
    <tr><td class="paramname">sigma</td><td>scale </td></tr>
    <tr><td class="paramname">tau</td><td>inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is NaN, mu is infinite, sigma is negative or infinite or tau is negative or infinite. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../db/d1f/opencl_2prim_2skew__double__exponential__lpdf_8hpp_source.html#l00040">40</a> of file <a class="el" href="../../db/d1f/opencl_2prim_2skew__double__exponential__lpdf_8hpp_source.html">skew_double_exponential_lpdf.hpp</a>.</p>

</div>
</div>
<a id="gac950822e01ad7173a9f42c571933eb06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac950822e01ad7173a9f42c571933eb06">&#9670;&nbsp;</a></span>skew_normal_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl&gt; stan::math::skew_normal_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The log of the skew normal density for the specified scalar(s) given the specified mean(s), deviation(s) and shape(s). y, mu, sigma, or alpha can each be either a scalar or a vector <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mean/deviation quadruple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of shape parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale parameter(s) </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) shape parameter(s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of the densities. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/dfa/opencl_2prim_2skew__normal__lpdf_8hpp_source.html#l00042">42</a> of file <a class="el" href="../../d7/dfa/opencl_2prim_2skew__normal__lpdf_8hpp_source.html">skew_normal_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga38acf71383b36f5db4ed878c9415b7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38acf71383b36f5db4ed878c9415b7d4">&#9670;&nbsp;</a></span>std_normal_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl&gt; stan::math::std_normal_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the standard normal cumulative distribution function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d1/dd3/opencl_2prim_2std__normal__cdf_8hpp_source.html#l00026">26</a> of file <a class="el" href="../../d1/dd3/opencl_2prim_2std__normal__cdf_8hpp_source.html">std_normal_cdf.hpp</a>.</p>

</div>
</div>
<a id="ga3d733b180253da7249ae23e4e9bda790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d733b180253da7249ae23e4e9bda790">&#9670;&nbsp;</a></span>std_normal_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl&gt; stan::math::std_normal_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log standard normal complementary cumulative distribution function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../db/df5/opencl_2prim_2std__normal__lccdf_8hpp_source.html#l00027">27</a> of file <a class="el" href="../../db/df5/opencl_2prim_2std__normal__lccdf_8hpp_source.html">std_normal_lccdf.hpp</a>.</p>

</div>
</div>
<a id="gac4c94cfff116dc2477617f242e356ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4c94cfff116dc2477617f242e356ede">&#9670;&nbsp;</a></span>std_normal_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl&gt; stan::math::std_normal_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log standard normal complementary cumulative distribution function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d1/d46/opencl_2prim_2std__normal__lcdf_8hpp_source.html#l00181">181</a> of file <a class="el" href="../../d1/d46/opencl_2prim_2std__normal__lcdf_8hpp_source.html">std_normal_lcdf.hpp</a>.</p>

</div>
</div>
<a id="ga48200e7b64861fad93fcdf7b24c8cac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48200e7b64861fad93fcdf7b24c8cac4">&#9670;&nbsp;</a></span>std_normal_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl&gt; stan::math::std_normal_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The log of the normal density for the specified scalar(s) given a location of 0 and a scale of 1. y can be either a scalar or a vector.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Sequence of scalars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of the densities. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if any scalar is nan. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d83/opencl_2prim_2std__normal__lpdf_8hpp_source.html#l00032">32</a> of file <a class="el" href="../../d2/d83/opencl_2prim_2std__normal__lpdf_8hpp_source.html">std_normal_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga8a3e85cdcb831735bf845adf1c42e234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a3e85cdcb831735bf845adf1c42e234">&#9670;&nbsp;</a></span>student_t_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl&gt; stan::math::student_t_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof_cl &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The log of the Student-t density for the given y, nu, mean, and scale parameter. The scale parameter must be greater than 0.</p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; t_{\nu} (\mu, \sigma^2) \\ \log (p (y \, |\, \nu, \mu, \sigma) ) &amp;=&amp; \log \left( \frac{\Gamma((\nu + 1) /2)} {\Gamma(\nu/2)\sqrt{\nu \pi} \sigma} \left( 1 + \frac{1}{\nu} (\frac{y - \mu}{\sigma})^2 \right)^{-(\nu + 1)/2} \right) \\ &amp;=&amp; \log( \Gamma( (\nu+1)/2 )) - \log (\Gamma (\nu/2) - \frac{1}{2} \log(\nu \pi) - \log(\sigma) -\frac{\nu + 1}{2} \log (1 + \frac{1}{\nu} (\frac{y - \mu}{\sigma})^2) \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_dof_cl</td><td>type of degrees of freedom </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom. </td></tr>
    <tr><td class="paramname">mu</td><td>The mean of the Student-t distribution. </td></tr>
    <tr><td class="paramname">sigma</td><td>The scale parameter of the Student-t distribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Student-t density at y. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if sigma is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than 0. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/d73/opencl_2prim_2student__t__lpdf_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../d4/d73/opencl_2prim_2student__t__lpdf_8hpp_source.html">student_t_lpdf.hpp</a>.</p>

</div>
</div>
<a id="gaccde2dd41ea6e10cce3f5fd53dbfa0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccde2dd41ea6e10cce3f5fd53dbfa0ea">&#9670;&nbsp;</a></span>to_array_1d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::to_array_1d </td>
          <td>(</td>
          <td class="paramtype">T_x &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns input matrix reshaped into a vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector representation of the input </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d68/opencl_2prim_2to__array__1d_8hpp_source.html#l00021">21</a> of file <a class="el" href="../../d5/d68/opencl_2prim_2to__array__1d_8hpp_source.html">to_array_1d.hpp</a>.</p>

</div>
</div>
<a id="gae58346dcff1afcdf893e0c0e2ab7fbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae58346dcff1afcdf893e0c0e2ab7fbe3">&#9670;&nbsp;</a></span>to_array_2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_x stan::math::to_array_2d </td>
          <td>(</td>
          <td class="paramtype">T_x &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns input matrix converted into a nested std vector. With <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> that is the same type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector representation of the input </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/d12/opencl_2prim_2to__array__2d_8hpp_source.html#l00021">21</a> of file <a class="el" href="../../d4/d12/opencl_2prim_2to__array__2d_8hpp_source.html">to_array_2d.hpp</a>.</p>

</div>
</div>
<a id="ga0aabc784b5f56edb079f21a48efdad54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aabc784b5f56edb079f21a48efdad54">&#9670;&nbsp;</a></span>to_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_x stan::math::to_matrix </td>
          <td>(</td>
          <td class="paramtype">T_x &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns input matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matrix representation of the input </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../db/d80/opencl_2prim_2to__matrix_8hpp_source.html#l00021">21</a> of file <a class="el" href="../../db/d80/opencl_2prim_2to__matrix_8hpp_source.html">to_matrix.hpp</a>.</p>

</div>
</div>
<a id="ga824d07dfec68229d759d260c865e9747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga824d07dfec68229d759d260c865e9747">&#9670;&nbsp;</a></span>to_matrix_cl() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_eigen_vt&lt; is_var, T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt;<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;<a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt;<a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt;T&gt; &gt; &gt; &gt; stan::math::to_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the source vector of <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrices of vars to the destination matrix that is stored on the OpenCL device. Each element of the vector is stored into one column of the returned <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source vector of <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> with a copy of the data in the source matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html#l00089">89</a> of file <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga34a35989520c40a236b8870762dd0db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34a35989520c40a236b8870762dd0db0">&#9670;&nbsp;</a></span>to_matrix_cl() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt;<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;<a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt;T&gt; &gt; &gt; stan::math::to_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the source std::vector of vars to a destination var that has data stored on the OpenCL device.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the std::vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>source <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>var with a copy of the data on the OpenCL device </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html#l00049">49</a> of file <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga095903e22c477b60e69e174c307bd423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga095903e22c477b60e69e174c307bd423">&#9670;&nbsp;</a></span>to_matrix_cl() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_eigen_vt&lt; is_var, T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt;<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;<a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt;<a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt;T&gt; &gt; &gt; &gt; stan::math::to_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the source <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix of vars to the destination matrix that is stored on the OpenCL device.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Compile time rows of the <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix </td></tr>
    <tr><td class="paramname">C</td><td>Compile time columns of the <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> with a copy of the data in the source matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html#l00067">67</a> of file <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga46313382ff3fae62c662662f93290572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46313382ff3fae62c662662f93290572">&#9670;&nbsp;</a></span>to_matrix_cl() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt;<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;<a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt;T&gt; &gt; &gt; stan::math::to_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the source var containing <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrices to destination var that has data stored on the OpenCL device.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>source <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>var with a copy of the data on the OpenCL device </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga8bbce98664097d5ea8e55b0b931bd721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bbce98664097d5ea8e55b0b931bd721">&#9670;&nbsp;</a></span>to_matrix_cl() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_st_arithmetic&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;<a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt;T&gt; &gt; stan::math::to_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the source <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix, <code>std::vector</code> or scalar to the destination matrix that is stored on the OpenCL device. The function also accepts <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code>s in which case it just returns the argument. If a lvalue matrix is passed to this function the caller must make sure that the matrix does not go out of scope before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.wait_for_write_events()</code> or <code>.wait_for_read_write_events()</code> on returned matrix or any matrix that is calculated from that one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> with a copy of the data in the source matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00045">45</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga08a3715205cf6c1564a87de73c13c22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08a3715205cf6c1564a87de73c13c22a">&#9670;&nbsp;</a></span>to_row_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::to_row_vector </td>
          <td>(</td>
          <td class="paramtype">T_x &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns input matrix reshaped into a row vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the row vector representation of the input </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d1f/opencl_2prim_2to__row__vector_8hpp_source.html#l00021">21</a> of file <a class="el" href="../../de/d1f/opencl_2prim_2to__row__vector_8hpp_source.html">to_row_vector.hpp</a>.</p>

</div>
</div>
<a id="ga0026608053df548f73f9556ffa94dc03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0026608053df548f73f9556ffa94dc03">&#9670;&nbsp;</a></span>to_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::to_vector </td>
          <td>(</td>
          <td class="paramtype">T_x &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns input matrix reshaped into a vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector representation of the input </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d15/opencl_2prim_2to__vector_8hpp_source.html#l00021">21</a> of file <a class="el" href="../../df/d15/opencl_2prim_2to__vector_8hpp_source.html">to_vector.hpp</a>.</p>

</div>
</div>
<a id="gafccee2b081b9edd7c6e6d211157e5490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafccee2b081b9edd7c6e6d211157e5490">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> stan::math::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transposes a view - swaps lower and upper parts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>view to transpose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposition of input </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00055">55</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="ga57ff9a795bfa5ae75421d00a95e8a6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57ff9a795bfa5ae75421d00a95e8a6c0">&#9670;&nbsp;</a></span>tri_inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_cl_view matrix_view = matrix_cl_view::Entire, typename T , require_matrix_cl_st&lt; std::is_floating_point, T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/dce/namespacestan.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt;T&gt; stan::math::tri_inverse </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the inverse of a triangular matrix</p>
<p>For a full guide to how this works and fits into Cholesky decompositions, see the reference report <a href="https://github.com/SteveBronder/stancon2018/blob/master/report.pdf">here</a> and kernel doc <a href="https://github.com/stan-dev/math/wiki/GPU-Kernels">here</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse of A</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dfb/tri__inverse_8hpp_source.html#l00040">40</a> of file <a class="el" href="../../d4/dfb/tri__inverse_8hpp_source.html">tri_inverse.hpp</a>.</p>

</div>
</div>
<a id="ga0e86538bd3a160cb58989ff68aa81456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e86538bd3a160cb58989ff68aa81456">&#9670;&nbsp;</a></span>uniform_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_low_cl, T_high_cl&gt; stan::math::uniform_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the uniform cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_low_cl</td><td>type of low bounds </td></tr>
    <tr><td class="paramname">T_high_cl</td><td>type of high bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>Sequence of low bounds. </td></tr>
    <tr><td class="paramname">beta</td><td>Sequence of high bounds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d1/d21/opencl_2prim_2uniform__cdf_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../d1/d21/opencl_2prim_2uniform__cdf_8hpp_source.html">uniform_cdf.hpp</a>.</p>

</div>
</div>
<a id="gab2dacadd5737ffbb65288cef66d1cfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2dacadd5737ffbb65288cef66d1cfb7">&#9670;&nbsp;</a></span>uniform_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_low_cl, T_high_cl&gt; stan::math::uniform_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log uniform complementary cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_low_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_high_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">beta</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dbf/opencl_2prim_2uniform__lccdf_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../d5/dbf/opencl_2prim_2uniform__lccdf_8hpp_source.html">uniform_lccdf.hpp</a>.</p>

</div>
</div>
<a id="ga260dc4fb650cc809b40e338144ccbf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga260dc4fb650cc809b40e338144ccbf1e">&#9670;&nbsp;</a></span>uniform_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_low_cl, T_high_cl&gt; stan::math::uniform_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log uniform cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_low_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_high_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">beta</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/df6/opencl_2prim_2uniform__lcdf_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../d3/df6/opencl_2prim_2uniform__lcdf_8hpp_source.html">uniform_lcdf.hpp</a>.</p>

</div>
</div>
<a id="ga8c081c9922500bedd293b98080c246a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c081c9922500bedd293b98080c246a9">&#9670;&nbsp;</a></span>uniform_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_low_cl, T_high_cl&gt; stan::math::uniform_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The log of a uniform density for the given y, lower, and upper bound.</p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{U}}(\alpha, \beta) \\ \log (p (y \, |\, \alpha, \beta)) &amp;=&amp; \log \left( \frac{1}{\beta-\alpha} \right) \\ &amp;=&amp; \log (1) - \log (\beta - \alpha) \\ &amp;=&amp; -\log (\beta - \alpha) \\ &amp; &amp; \mathrm{ where } \; y \in [\alpha, \beta], \log(0) \; \mathrm{otherwise} \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_low_cl</td><td>type of lower bound </td></tr>
    <tr><td class="paramname">T_high_cl_cl</td><td>type of upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">alpha</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">beta</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the lower bound is greater than or equal to the lower bound </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/ddb/opencl_2prim_2uniform__lpdf_8hpp_source.html#l00042">42</a> of file <a class="el" href="../../d7/ddb/opencl_2prim_2uniform__lpdf_8hpp_source.html">uniform_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga02f96945c94514afc7c296e5ed4f461e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02f96945c94514afc7c296e5ed4f461e">&#9670;&nbsp;</a></span>weibull_cdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_shape_cl, T_scale_cl&gt; stan::math::weibull_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the weibull cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/d04/opencl_2prim_2weibull__cdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../d4/d04/opencl_2prim_2weibull__cdf_8hpp_source.html">weibull_cdf.hpp</a>.</p>

</div>
</div>
<a id="ga143c39f3c5b17a11b8fac657716a1ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga143c39f3c5b17a11b8fac657716a1ca8">&#9670;&nbsp;</a></span>weibull_lccdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_shape_cl, T_scale_cl&gt; stan::math::weibull_lccdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the weibull log cumulative complementary distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/d4a/opencl_2prim_2weibull__lccdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../dd/d4a/opencl_2prim_2weibull__lccdf_8hpp_source.html">weibull_lccdf.hpp</a>.</p>

</div>
</div>
<a id="ga77ff0157eda0b5a11c6cacd5bcc07e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77ff0157eda0b5a11c6cacd5bcc07e42">&#9670;&nbsp;</a></span>weibull_lcdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_shape_cl, T_scale_cl&gt; stan::math::weibull_lcdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the weibull log cumulative distribution function for the given location, and scale. If given containers of matching sizes returns the product of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d35/opencl_2prim_2weibull__lcdf_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../de/d35/opencl_2prim_2weibull__lcdf_8hpp_source.html">weibull_lcdf.hpp</a>.</p>

</div>
</div>
<a id="ga9ecf070a86a3bb30c08ced16a1c1bb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ecf070a86a3bb30c08ced16a1c1bb32">&#9670;&nbsp;</a></span>weibull_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_y_cl, T_shape_cl, T_scale_cl&gt; stan::math::weibull_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the Weibull log probability density for the given location and scale. Given containers of matching sizes, returns the log sum of probability densities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of real parameter </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of shape parameter </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>real parameter </td></tr>
    <tr><td class="paramname">alpha</td><td>shape parameter </td></tr>
    <tr><td class="paramname">sigma</td><td>scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability density or log sum of probability densities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is negative, alpha or sigma are nonpositive </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/db8/opencl_2prim_2weibull__lpdf_8hpp_source.html#l00035">35</a> of file <a class="el" href="../../d4/db8/opencl_2prim_2weibull__lpdf_8hpp_source.html">weibull_lpdf.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__opencl_html_gadf2a61125c6dca5e5a400d56e24cc6d5"><div class="ttname"><a href="../../d5/de5/group__opencl.html#gadf2a61125c6dca5e5a400d56e24cc6d5">stan::math::from_matrix_cl</a></div><div class="ttdeci">auto from_matrix_cl(const T &amp;src)</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/deb/copy_8hpp_source.html#l00061">copy.hpp:61</a></div></div>
<div class="ttc" id="agroup__opencl_html_ga8bbce98664097d5ea8e55b0b931bd721"><div class="ttname"><a href="../../d5/de5/group__opencl.html#ga8bbce98664097d5ea8e55b0b931bd721">stan::math::to_matrix_cl</a></div><div class="ttdeci">matrix_cl&lt; scalar_type_t&lt; T &gt; &gt; to_matrix_cl(T &amp;&amp;src)</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/deb/copy_8hpp_source.html#l00045">copy.hpp:45</a></div></div>
<div class="ttc" id="agroup__opencl__kernels_html_gacdabec78c1cd7feac6047ddd6289800d"><div class="ttname"><a href="../../dc/d5d/group__opencl__kernels.html#gacdabec78c1cd7feac6047ddd6289800d">stan::math::opencl_kernels::cholesky_decompose</a></div><div class="ttdeci">const kernel_cl&lt; in_out_buffer, int &gt; cholesky_decompose(&quot;cholesky_decompose&quot;, {indexing_helpers, cholesky_decompose_kernel_code})</div></div>
<div class="ttc" id="anamespacestan_1_1math_html_a61ee1c81e14d0a137cfd8bc8f1ddac46"><div class="ttname"><a href="../../d4/d84/namespacestan_1_1math.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">stan::math::vari</a></div><div class="ttdeci">vari_value&lt; double &gt; vari</div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d6c/rev_2core_2vari_8hpp_source.html#l00197">vari.hpp:197</a></div></div>

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
