<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: Getting Started Guide</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../$standoxy.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">4.3.2</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d1/d66/getting_started.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Getting Started Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is meant as a basic guide for writing and maintaining functions in the <a href="https://github.com/stan-dev/math">stan-dev/math</a> repository. Stan Math is the automatic differentiation (autodiff) library behind the Stan language, and the vast majority of the functions exposed at the Stan language level are implemented here in C++.</p>
<p>In the course of the Math library's existence, C++ has changed substantially. Math was originally written before C++11. It currently targets C++14. In the near future it will transition to C++17. With this in mind, there are many different ways to write Math functions. This guide tries to document best practices, conventions which not all functions in Math follow, but should be followed for new code to keep the code from getting unwieldy (the old patterns will be updated eventually).</p>
<p>The title contains "Current State" to emphasize that if any information here is out of date or any advice does not work, it should be reported as a bug (the <a href="https://github.com/stan-dev/example-models">example-models</a>).</p>
<p>This document builds on the information in the <a href="https://arxiv.org/abs/1509.07164">Stan Math Library</a> which should be skimmed over before .</p>
<h1><a class="anchor" id="autotoc_md82"></a>
Preliminary Resources:</h1>
<p>Before contributing to Stan Math it's recommended you become familiar with C++. While this guide attempts to cover the edges and odd things we do in the math library, we recommend the resources below for getting started on autodiff in C++.</p>
<p>Books:</p><ul>
<li><a href="https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996">Effective Modern C++</a></li>
<li><a href="https://github.com/bob-carpenter/ad-handbook/blob/master/ad-handbook-draft.pdf">Bob's autodiff book</a></li>
<li><a href="https://www.amazon.com/C-Templates-Complete-Guide-2nd/dp/0321714121">C++ Templates: The Complete Guide</a></li>
<li><a href="https://www.amazon.com/Numerical-Recipes-3rd-Scientific-Computing/dp/0521880688">Numerical Recipes</a></li>
</ul>
<p>Talks:</p><ul>
<li><a href="https://www.youtube.com/watch?v=PorfLSr3DDI">Give me 15 minutes &amp; I'll change your view of GDB</a></li>
<li><a href="https://www.youtube.com/watch?v=bSkpMdDe4g4">What Has My Compiler Done for Me Lately?</a></li>
<li><a href="https://www.youtube.com/watch?v=2EWejmkKlxs">Going Nowwhere Faster</a></li>
</ul>
<p>Blog Posts:</p><ul>
<li><a href="https://blog.mc-stan.org/2020/11/23/thinking-about-automatic-differentiation-in-fun-new-ways/">Thinking About Automatic Differentiation in Fun New Ways</a></li>
</ul>
<p>A generally good resource for making minimal examples for bugs is <a href="https://godbolt.org/">godbolt.org</a></p>
<h1><a class="anchor" id="autotoc_md83"></a>
Code Structure</h1>
<p>The Stan Math library is spit into 4 main source folders that hold functions, type traits, and classes.</p>
<ul>
<li>prim: General <code>Scalar</code>, <code>Matrix</code>, and <code>std::vector&lt;T&gt;</code> types</li>
<li>rev: Specializations for reverse mode automatic differentiation</li>
<li>fwd: Specializations for forward mode automatic differentiation.</li>
<li>mix: Sources to allow mixes of forward and reverse mode.</li>
<li>opencl: Sources for doing reverse mode automatic differentiation on GPUs.</li>
</ul>
<p>Within each of those folders you will find any one of the following folders</p>
<ul>
<li>core: Base implementations of custom scalars or backend setup.<ul>
<li>Ex: in <code>prim</code> this is operators for complex numbers and the setup for threading, <code>rev</code>'s core is the scalar and its base operators for reverse mode and the stack allocator, and <code>fwd</code> has the scalar for forward mode autodiff and its operators.</li>
</ul>
</li>
<li>err: Functions that perform a check and if true throw an error.</li>
<li>fun: The math functions exposed to the Stan language.</li>
<li>functor: Functions that take in other functions and data as input such as <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a6e156d0934e4aee29b8defd07962d9cd" title="Call an instance of the function ReduceFunction on every element of an input sequence and sum these t...">reduce_sum()</a></code></li>
<li>meta: Type traits for compile time deduction on types.</li>
</ul>
<p>Any function callable from the math library, excluding those in the <code>internal</code> namespace, should be compatible with Stan's reverse and forward mode autodiff types. Any new function introduced to the Math library is expected to support higher order automatic differentiation. Though exceptions to supporting higher order autodiff have been made in the past such as the differential equations solvers only supporting reverse mode autodiff.</p>
<p>The structure for contributing a function:</p><ul>
<li>Functions which operate on arithmetic and autodiff types go in <code>stan/math/prim</code>.</li>
<li>Functions specializations for reverse mode go in <code>stan/math/rev</code>.</li>
<li>Functions specializations for forward mode autodiff go in <code>stan/math/fwd</code></li>
<li>Functions specializations for a combination of both forward and reverse mode go in <code>stan/mat/mix/fun</code>.</li>
</ul>
<p>Adding a function to Stan can be as simple as adding a generic templated function to <code>prim/fun</code>. The <code>rev</code>, <code>fwd</code>, <code>mix</code>, and <code>opencl</code> folders are used for adding specialization for:</p>
<ol type="1">
<li>Performance</li>
<li>Better numerical behavior</li>
<li>Utilize particular hardware</li>
</ol>
<h1><a class="anchor" id="autotoc_md84"></a>
Adding a Simple Example function</h1>
<p>A generic function that performs a dot product on itself could be written in <code>prim/fun</code> as</p>
<div class="fragment"><div class="line"><span class="comment">// stan/math/prim/fun/dot_self.hpp</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#ac37be6da87f3444ae2f7a00f6fee2983">dot_self</a>(<span class="keyword">const</span> EigVec&amp; x) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; x_ref = <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a3145f3467ad20649633bbf9842ddf909">to_ref</a>(x); <span class="comment">// (1)</span></div>
<div class="line">  value_type_t&lt;EigVec&gt; sum_x = 0.0; <span class="comment">// (2)</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; x.size(); ++i) {</div>
<div class="line">    sum_x += x_ref.coeff(i) * x_ref.coeff(i); <span class="comment">// (3)</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> sum_x;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is pretty standard C++ besides (1), (2), and (3) which I'll go over here.</p>
<h3><a class="anchor" id="autotoc_md85"></a>
(1) Safe elementwise access for Eigen expressions</h3>
<p>TL;DR: Before accessing individual coefficients of an <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> type, use <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a3145f3467ad20649633bbf9842ddf909" title="This evaluates expensive Eigen expressions.">to_ref()</a></code> to make sure it's a type that's safe to access by coefficient.</p>
<p>In the Stan math library we allow functions to accept <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> expressions. This is rather nice as for instance the code</p>
<div class="fragment"><div class="line">Eigen::MatrixXd x = <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a68817034db6ea04cda51c87bc86329a6">multiply</a>(<a class="code" href="../../d2/d3c/group__opencl__kernel__generator.html#ga797d34ad217be5a5367c83b2babc4a19">add</a>(A, <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a68817034db6ea04cda51c87bc86329a6">multiply</a>(B, C)), <a class="code" href="../../d2/d3c/group__opencl__kernel__generator.html#ga797d34ad217be5a5367c83b2babc4a19">add</a>(D, E));</div>
</div><!-- fragment --><p>Actually delays evaluation when making <code>x</code> and produces an object of type</p>
<div class="fragment"><div class="line">Eigen::Product&lt;Eigen::Add&lt;Matrix, Eigen::Product&lt;Matrix, Matrix&gt;&gt;, Eigen::Add&lt;Matrix, Matrix&gt;&gt;</div>
</div><!-- fragment --><p>Using lazily evaluated expressions allows <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> to avoid redundant copies, reads, and writes to our data. However, this comes at a cost.</p>
<p>In (2), when we access the coefficients of <code>x</code>, if its type is similar to the wacky expression above we can get incorrect results as <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> does not guarantee any safety of results when performing coefficient level access on a expression type that transforms its inputs. So <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a3145f3467ad20649633bbf9842ddf909" title="This evaluates expensive Eigen expressions.">to_ref()</a></code> looks at its input type, and if the input type is an <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> expression that it evaluates the expression so that all the computations are performed and the return object is then safe to access.</p>
<p>But! Suppose our input is something like</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;var, Dynamic, 1&gt; A = Eigen::VectorXd::Random(20);</div>
<div class="line"><a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> b = <a class="code" href="../../d4/d84/namespacestan_1_1math.html#ac37be6da87f3444ae2f7a00f6fee2983">dot_self</a>(A.segment(1, 5));</div>
</div><!-- fragment --><p>Here, we will have an expression <code>Eigen::Block&lt;Eigen::MatrixXd&gt;</code> as the input type. But an expression that is only a view into an object is safe to read coefficent-wise. In this case <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a3145f3467ad20649633bbf9842ddf909" title="This evaluates expensive Eigen expressions.">to_ref()</a></code> knows this and, as long as you used <code>const auto&amp;</code> as the object type returned from <code>to_ref(x)</code>, then <code>to_ref(x)</code> will deduce the correct type <code>Block</code> instead of casting to an evaluated vector. We use <code>const auto&amp;</code> here even when the output will store an object as C++'s <a href="https://en.cppreference.com/w/cpp/language/lifetime">lifetime</a> rules allow for this.</p>
<blockquote class="doxtable">
<p>The lifetime of a temporary object may be extended by binding to a const lvalue reference or to an rvalue reference (since C++11), see reference initialization for details. </p>
</blockquote>
<p>If we used <code>auto</code> here then if the return type of <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a3145f3467ad20649633bbf9842ddf909" title="This evaluates expensive Eigen expressions.">to_ref()</a></code> was an <code>Eigen::MatrixXd</code> then it would make a copy. But with <code>const auto&amp;</code> we do not make a copy the lifetime of the object referenced by the <code>const auto&amp;</code> will be the same as if we had done <code>auto</code></p>
<h3><a class="anchor" id="autotoc_md86"></a>
(2) Using &lt;tt&gt;value_type_t&lt;&gt;&lt;/tt&gt; and Friends</h3>
<p>The type trait <code>value_type_t</code> is one of several type traits we use in the library to query information about types. <code>value_type_t</code> will return the inner type of a container, so <code>value_type_t&lt;Eigen::Matrix&lt;double, -1, -1&gt;&gt;</code> will return <code>double</code>, <code>value_type_t&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;</code> will return a <code>std::vector&lt;double&gt;</code> and <code>value_type_t&lt;double&gt;</code> will simply return a double. See the module on type traits for a guide on Stan's specific type traits.</p>
<h3><a class="anchor" id="autotoc_md87"></a>
(3) Accessing Eigen matrices though &lt;tt&gt;.coeff()&lt;/tt&gt; and &lt;tt&gt;.coeffRef()&lt;/tt&gt;</h3>
<p>This is a small bit, but <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> performs bounds checks by default when using <code>[]</code> or <code>()</code> to access elements. However <code>.coeff()</code> and <code>.coeffRef()</code> do not. Because Stan model's perform bounds checking at a higher level its safe to remove the bounds checks here.</p>
<h3><a class="anchor" id="autotoc_md88"></a>
Testing</h3>
<p>From there you can use the unit <a class="el" href="../../d4/dd4/autodiff_test_guide.html">test suite for automatic differentiation</a> to verify your code produces the correct gradients and higher order derivatives and your done!</p>
<div class="fragment"><div class="line"><span class="comment">// Example tests in test/unit/math/mix/fun/dot_self_test.cpp</span></div>
<div class="line">TEST(MathMixMatFun, dotSelf) {</div>
<div class="line">  <span class="keyword">auto</span> f = [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; y) { <span class="keywordflow">return</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#ac37be6da87f3444ae2f7a00f6fee2983">stan::math::dot_self</a>(y); };</div>
<div class="line"> </div>
<div class="line">  Eigen::VectorXd x0(0);</div>
<div class="line">  Eigen::VectorXd x1(1);</div>
<div class="line">  x1 &lt;&lt; 2;</div>
<div class="line">  Eigen::VectorXd x2(2);</div>
<div class="line">  x2 &lt;&lt; 2, 3;</div>
<div class="line">  Eigen::VectorXd x3(3);</div>
<div class="line">  x3 &lt;&lt; 2, 3, 4;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : std::vector&lt;Eigen::VectorXd&gt;{x0, x1, x2, x3}) {</div>
<div class="line">    stan::test::expect_ad(f, a);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>That's it, your done! Make a PR, add some docs, have a cup of tea all is well.</p>
<p>But, while your function will work for all of our types, it probably won't be as fast as it could be. Indeed, since the above is using Stan's basic scalar reverse mode, for a vector of size N there will be N individual callback functions on the reverse pass callback stack. This is not the worst, Stan's base scalar operations are as efficient as they can be, but by writing a specialization for reverse mode we can just have one callback with much more efficient memory access. The next section may seem a bit advanced, but those who enjoy adventure, let's talk about how to make this function go faster.</p>
<h1><a class="anchor" id="autotoc_md89"></a>
Specializing for Reverse Mode</h1>
<p>At this point I'll assume you have looked over the preliminary resources listed above describing Stan math's automatic differentiation.</p>
<p>For reverse mode we can do the math by hand or use a site like <a href="http://www.matrixcalculus.org/">matrixcalculus.org</a> to find the adjoint method for a self dot product is</p>
<div class="fragment"><div class="line">x.adj() += sum_x.adj() * 2.0 * x.val()</div>
</div><!-- fragment --><p>and so we want to add a specialization in <code>stan/math/rev/fun</code> that calculates reverse mode's adjoint directly. The methods on <code>x</code> above use custom <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> methods for matrices, vectors, and arrays, <code>.val()</code> and <code>.adj()</code>. For an <code>Eigen::Matrix&lt;var, Rows, Cols&gt;</code> the internal <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> representation comes down to a struct holding an array of <code>var</code> types and information on the row and column sizes.</p>
<div class="fragment"><div class="line">struct DenseStorage {</div>
<div class="line">  var* m_data; // array of Stan&#39;s var type</div>
<div class="line">  Eigen::Index m_rows;</div>
<div class="line">  Eigen::Index m_cols;</div>
<div class="line">}</div>
</div><!-- fragment --><p>It's very common for us to want to access just the <code>val_</code> or <code>adj_</code> of the <code>vari</code>'s inside of the <code>var</code>'s and so we have written custom methods <code>.adj()</code> and <code>.val()</code> using <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a>'s plugin system which returns an expression of an <code>Eigen::Matrix&lt;double, Rows, Cols&gt;</code> representing the <code>var</code>'s values and adjoints, respectively.</p>
<h3><a class="anchor" id="autotoc_md90"></a>
Using type traits to Expose Our New Function</h3>
<p>First we need to stop our current function from compiling for reverse mod autodiff. This can be done using the <a class="el" href="../../d1/db9/group__require__meta.html">requires</a> type traits in stan. The only thing that has changed in the function above and below is the new non-type template parameter (<a href="https://en.cppreference.com/w/cpp/language/template_parameters">NTTP</a>) that is now in the template definition.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, require_not_st_var&lt;EigVec&gt;* = <span class="keywordtype">nullptr</span>&gt; <span class="comment">// (1)</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#ac37be6da87f3444ae2f7a00f6fee2983">dot_self</a>(<span class="keyword">const</span> EigVec&amp; x) {</div>
<div class="line">  <span class="keyword">auto</span> x_ref = <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a3145f3467ad20649633bbf9842ddf909">to_ref</a>(x);</div>
<div class="line">  <a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a7953d993880449ed4d741e6e891d2f7b">sum</a> = 0.0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; x.size(); ++i) {</div>
<div class="line">    <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a7953d993880449ed4d741e6e891d2f7b">sum</a> += x_ref.coeff(i) * x_ref.coeff(i);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a7953d993880449ed4d741e6e891d2f7b">sum</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>TL;DR: Use Stan's <code>require</code> type trait library for limiting a function's scope to certain types.</p>
<p>Reading from left to right, <code>require_not_st_var</code> requires that a signature's template does <em>not have a scalar type of a <code>var</code></em>. This line is exactly the same as</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, std::enable_if_t&lt;is_var&lt;scalar_type_t&lt;EigVec&gt;&gt;::value&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
</div><!-- fragment --><p>but we tend to use these type traits so frequently in the math library it made sense to write specializations for them.</p>
<p>But how does that line work? Note that, on success, <code>std::enable_if_t</code> returns a <code>void</code> type, and on failure the functions is removed from the set of possible signatures though Substitution Failure is not an Error <a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a>. So on success the template signature is</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, <span class="keywordtype">void</span>* = <span class="keywordtype">nullptr</span>&gt;</div>
</div><!-- fragment --><p>where <code>void* = nullptr</code> follows a nice little rule in the C++ standard that says any void pointer non-type template parameters with a default value of a <code>nullptr</code> will be ignored by template instantiation. So good! We get exactly what we want at the expense of a some annoying legalize and a bit of an odd <code>nullptr</code> style syntax.</p>
<p>So we stopped our original function for compiling for <code>var</code> types and now we can add a specialization that does work for <code>var</code>.</p>
<h2><a class="anchor" id="autotoc_md91"></a>
Working in Reverse Mode</h2>
<p>So now let's write our reverse mode specialization in <code>rev/fun</code>.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, require_eigen_vt&lt;is_var, EigVec&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#ac37be6da87f3444ae2f7a00f6fee2983">dot_self</a>(<span class="keyword">const</span> EigVec&amp; v) {</div>
<div class="line">  <span class="comment">// (1) put v into our arena</span></div>
<div class="line">  arena_t&lt;EigVec&gt; arena_v(v);</div>
<div class="line">   <span class="comment">// calculate forward pass</span></div>
<div class="line">  <a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> res = arena_v.val().dot(arena_v.val());</div>
<div class="line">  <span class="comment">// (2) Place a callback for the reverse pass on the callback stack.</span></div>
<div class="line">  <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a4dc059c1f55cae403aba50db7866e80e">reverse_pass_callback</a>([res, arena_v]() <span class="keyword">mutable</span> {</div>
<div class="line">    arena_v.adj().array() += (2.0 * res.adj().array()) * arena_v.val().array();</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
</div><!-- fragment --><p>There's a lot going on here particular to Stan math and so we will talk about each special bit.</p>
<h2><a class="anchor" id="autotoc_md92"></a>
(1) Arena memory</h2>
<p>The type <code>arena_t&lt;T&gt;</code> and the function <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a713cc9385182249d547389028a723a1a" title="Converts given argument into a type that either has any dynamic allocation on AD stack or schedules i...">to_arena()</a></code> takes an object and places it on Stan's arena allocator.</p>
<p>Remember from <a href="https://blog.mc-stan.org/2020/11/23/thinking-about-automatic-differentiation-in-fun-new-ways/">Thinking About Automatic Differentiation in Fun New Ways</a> reverse mode automatic differentiation comes down to.</p>
<ol type="1">
<li>Calculating a function z = f(x, y)â€˜s output (forward pass)</li>
<li>Storing the input and output into a memory arena</li>
<li>Adding a callback to a callback stack that calculates the adjoint of the function</li>
</ol>
<p>This process allows us to call <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#ae47da1792e5d3b1564c57ecb3a0de900" title="Compute the gradient for all variables starting from the end of the AD tape.">grad()</a></code> and from the last in, call each of the callbacks in the callback stack and accumulates the gradients through all the outputs and inputs. (reverse pass)</p>
<p>Reverse mode autodiff in Math requires a huge number of temporaries and intermediates to be computed and saved for the reverse pass. There are so many allocations that the overhead of <code>malloc()</code> becomes noticeable. To avoid this, Math provides its own memory arena. The assumptions of the Math arena are:</p>
<ol type="1">
<li>Objects allocated in the arena are <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">TriviallyCopyable</a> and <a href="https://en.cppreference.com/w/cpp/language/destructor#Trivial_destructor">TriviallyDestructable</a>. These objects do not need their destructors called (although there are ways to destruct something allocated in the arena, it just isn't automatic).</li>
<li>All objects allocated on the arena have the same lifetime (that is the lifetime of the stack - until <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#afe2cbb83ac9ef52296755690e61f4298" title="Recover memory used for all variables for reuse.">recover_memory()</a></code> is called).</li>
</ol>
<p>The arena memory pattern fits nicely into automatic differentiation for MCMC as we will most commonly be calling gradients with data of the same size over and over again.</p>
<p>Functions that use reverse mode autodiff are allowed to save what they need to the arena and then the objects saved here will be available during the reverse pass.</p>
<p>There is a utility for saving objects into the arena that do need their destructors called. This is discussed under <code>make_callback_ptr()</code>. Arena types are helper functions and types for easily saving variables to the arena.</p>
<p><code>arena_t&lt;T&gt;</code> defines, for a given type <code>T</code>, the type of a lightweight object pointing to memory in the arena that can store a <code>T</code>. Memory for <code>arena_t&lt;T&gt;</code> objects is only recovered when <code>recover_memory</code> is called. No destructors are called for objects stored with <code>arena_t&lt;T&gt;()</code>.</p>
<p>Copying a variable <code>x</code> to the arena can be done with either <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a713cc9385182249d547389028a723a1a" title="Converts given argument into a type that either has any dynamic allocation on AD stack or schedules i...">to_arena()</a></code> or <code>arena_t&lt;T&gt;</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> myfunc(<span class="keyword">const</span> T&amp; x) {</div>
<div class="line">  <span class="keyword">auto</span> arena_x = <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a713cc9385182249d547389028a723a1a">to_arena</a>(x);</div>
<div class="line">  <span class="comment">//...</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> myfunc(<span class="keyword">const</span> T&amp; x) {</div>
<div class="line">  arena_t&lt;T&gt; arena_x = x;</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md93"></a>
(2) Setting up the Reverse Pass</h1>
<p>Once we have stored the data we need for the reverse pass we need to actually write that reverse pass! We need to take our adjoint calculation and put it onto the callback stack so that when the users call <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#ae47da1792e5d3b1564c57ecb3a0de900" title="Compute the gradient for all variables starting from the end of the AD tape.">grad()</a></code> the adjoints are propagated upwards properly.</p>
<p>For this we have a function called <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a4dc059c1f55cae403aba50db7866e80e" title="Puts a callback on the autodiff stack to be called in reverse pass.">reverse_pass_callback()</a></code>. Calling <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a4dc059c1f55cae403aba50db7866e80e" title="Puts a callback on the autodiff stack to be called in reverse pass.">reverse_pass_callback()</a></code> with a functor <code>f</code> creates an object on the callback stack that will call <code>f</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../d4/d84/namespacestan_1_1math.html#a4dc059c1f55cae403aba50db7866e80e">reverse_pass_callback</a>([res, arena_v]() <span class="keyword">mutable</span> { <span class="comment">// (2)</span></div>
<div class="line">  v.adj() += (2.0 * res.adj()) * v.val();</div>
<div class="line">});</div>
</div><!-- fragment --><p>Notice that the lambda we create <em>copies</em> the objects <code>res</code> and <code>arena_v</code>. The trick here is that, because anything allocated with Stan's arena using <code>arena_t</code> or <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a713cc9385182249d547389028a723a1a" title="Converts given argument into a type that either has any dynamic allocation on AD stack or schedules i...">to_arena()</a></code> are <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">TriviallyCopyable</a> (as are arithmetic scalars). So the memory is safe and sound within our arena and so these are safe and fast to copy.</p>
<p>An alternative approach to the above function could also have been</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, require_eigen_vt&lt;is_var, EigVec&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#ac37be6da87f3444ae2f7a00f6fee2983">dot_self</a>(<span class="keyword">const</span> EigVec&amp; v) {</div>
<div class="line">  arena_t&lt;EigVec&gt; arena_v(v); <span class="comment">// (1) put v into our arena</span></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#ab12dd8270b3ffc0ee066d306b240f4bb">make_callback_var</a>(arena_v.val().dot(arena_v.val()), [arena_v](<span class="keyword">auto</span>&amp; vi) {</div>
<div class="line">    arena_v.adj() += (2.0 * vi.adj()) * arena_v.val();</div>
<div class="line">  });</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>make_callback_var(x, f)</code> is similar to <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a4dc059c1f55cae403aba50db7866e80e" title="Puts a callback on the autodiff stack to be called in reverse pass.">reverse_pass_callback()</a></code>, but it constructs an autodiff type from the argument <code>x</code>. The function <code>f</code> is called on the reverse pass similarly to <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a4dc059c1f55cae403aba50db7866e80e" title="Puts a callback on the autodiff stack to be called in reverse pass.">reverse_pass_callback()</a></code>. <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#ab12dd8270b3ffc0ee066d306b240f4bb" title="Creates a new var initialized with a callback_vari with a given value and reverse-pass callback funct...">make_callback_var()</a></code> should only be used when returning back a <code>var&lt;double&gt;</code> or <code>var&lt;Matrix&gt;</code>.</p>
<h1><a class="anchor" id="autotoc_md94"></a>
Argument Types</h1>
<p>The functions in Stan Math are used in the C++ code generated by the Stan compiler. This means that all types in the Stan language map to <code>C++</code> types. The map between Stan types and types in <code>C++</code> is a one to many relationship because of the different blocks in a Stan program. Objects created in <code>data</code>, <code>transformed data</code>, and <code>generated quantities</code> will hold arithmetic types while objects created in <code>parameters</code>, <code>transformed parameters</code>, and the <code>model</code> block will hold autodiff types. The basic Stan types are listed in the table below as well as arrays of any of these types.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Stan Type </th><th class="markdownTableHeadNone">Data </th><th class="markdownTableHeadNone">Model  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>int</code> </td><td class="markdownTableBodyNone"><code>int</code> </td><td class="markdownTableBodyNone"><code>int</code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>int[N]</code> </td><td class="markdownTableBodyNone"><code>std::vector&lt;int&gt;</code> </td><td class="markdownTableBodyNone"><code>std::vector&lt;int&gt;</code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>real</code> </td><td class="markdownTableBodyNone"><code>double</code> </td><td class="markdownTableBodyNone"><code>var/fvar&lt;T&gt;</code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>real[N]</code> </td><td class="markdownTableBodyNone"><code>std::vector&lt;double&gt;</code> </td><td class="markdownTableBodyNone"><code>std::vector&lt;var/fvar&lt;T&gt;&gt;</code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vector[N]</code> </td><td class="markdownTableBodyNone"><code>Eigen::Matrix&lt;double, Dynamic, 1&gt;(N)</code> </td><td class="markdownTableBodyNone"><code>Eigen::Matrix&lt;var/fvar&lt;T&gt; Dynamic, 1&gt;(N)</code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>row_vector[N]</code> </td><td class="markdownTableBodyNone"><code>Eigen::Matrix&lt;double, 1, Dynamic&gt;(N)</code> </td><td class="markdownTableBodyNone"><code>Eigen::Matrix&lt;var/fvar&lt;T&gt; 1, Dynamic&gt;(N)</code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>matrix[N,M]</code> </td><td class="markdownTableBodyNone"><code>Eigen::Matrix&lt;double, Dynamic, Dynamic&gt;(N, M)</code> </td><td class="markdownTableBodyNone"><code>Eigen::Matrix&lt;var/fvar&lt;T&gt; Dynamic, Dynamic&gt;(N, M)</code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>matrix[N, M] x[K]</code> </td><td class="markdownTableBodyNone"><code>std::vector&lt;Eigen::Matrix&lt;double, Dynamic, Dynamic&gt;&gt;(K, {M, N})</code> </td><td class="markdownTableBodyNone"><code>std::vector&lt;Eigen::Matrix&lt;var/fvar&lt;T&gt; Dynamic, Dynamic&gt;&gt;(K, {M, N})</code>  </td></tr>
</table>
<p>Any array type (<code>int[]</code>, <code>real[]</code>, or <code>T[]</code> for <code>T</code> any of the above types) map to <code>std::vector&lt;C&gt;</code> types where <code>C</code> is the C++ equivalent of <code>T</code>.</p>
<h2><a class="anchor" id="autotoc_md95"></a>
Unary Functions Working Over Arrays</h2>
<p>The Stan function <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin()</a></code> expects the math library has the following signatures available.</p>
<div class="fragment"><div class="line"><a class="code" href="../../d4/d84/namespacestan_1_1math.html#a3e2385fde5624f0ea3c0d2c60d0568a5">real</a> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(<a class="code" href="../../d4/d84/namespacestan_1_1math.html#a3e2385fde5624f0ea3c0d2c60d0568a5">real</a>);</div>
<div class="line">vector <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(vector);</div>
<div class="line">array vector <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(array vector)</div>
</div><!-- fragment --><p>where <code>array</code> can actually be multiple arrays within one another. The above translates to the following C++ signatures</p>
<div class="fragment"><div class="line"><span class="comment">// reals</span></div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(<span class="keywordtype">double</span>);</div>
<div class="line"><a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(<a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a>);</div>
<div class="line"><span class="comment">// vector</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">Eigen::Vector&lt;T, Dynamic, 1&gt; <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(Eigen::Vector&lt;T, Dynamic, 1&gt;);</div>
<div class="line"><span class="comment">// array vector</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">std::vector&lt;Eigen::Vector&lt;T, Dynamic, 1&gt;&gt; <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(std::vector&lt;Eigen::Vector&lt;T, Dynamic, 1&gt;&gt;);</div>
<div class="line"><span class="comment">// array array vector</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">std::vector&lt;std::vector&lt;Eigen::Vector&lt;T, Dynamic, 1&gt;&gt;&gt; <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(std::vector&lt;std::vector&lt;Eigen::Vector&lt;T, Dynamic, 1&gt;&gt;&gt;);</div>
</div><!-- fragment --><p>A function that accepts an autodiff type should return an autodiff type. Notice that because we have to support arithmetic and autodiff types the signatures expand out for both arithmetic and autodiff types. It would be tedious and grueling to write out this method for all of the array types, so Stan math provides helper classes <code>apply_scalar_unary</code> and <code>apply_vector_unary</code> to apply a function over each array.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">struct </span>sin_fun {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> T fun(<span class="keyword">const</span> T&amp; x) {</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">std::sin</a>;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(x);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, require_not_container_st&lt;std::is_arithmetic, T&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(<span class="keyword">const</span> T&amp; x) {</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#adbd7c862016910e0217ad1893736bcce">apply_scalar_unary&lt;sin_fun, T&gt;::apply</a>(x);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container, require_container_st&lt;std::is_arithmetic, Container&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(<span class="keyword">const</span> Container&amp; x) {</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#adbd7c862016910e0217ad1893736bcce">apply_vector_unary&lt;Container&gt;::apply</a>(</div>
<div class="line">      x, [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v) { <span class="keywordflow">return</span> v.array().<a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(); });</div>
<div class="line">}</div>
</div><!-- fragment --><p>In Stan math, a <code>container</code> type is an <code>std::vector</code> that holds either other <code>std::vector</code>s or <code>Eigen::Matrix</code> types. So in the first function we use <code>apply_scalar_unary</code> to apply <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin()</a></code> to either <code>Scalar</code>s, <code>std::vector</code>s holding scalars, or <code>Eigen::Matrix</code> types. The second function which uses <code>apply_vector_unary()</code> will apply its lambda to the container's whose elements are also containers or <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrices.</p>
<h2><a class="anchor" id="autotoc_md96"></a>
Binary Functions (and least-upper-bound return type semantics)</h2>
<p>Multiple argument functions are more involved. Consider <code>real atan2(real, real)</code> which requires four C++ overloads:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a0c4868ee5c5ab673ee54e5dce3be37f1">atan2</a>(<span class="keywordtype">double</span>, <span class="keywordtype">double</span>);</div>
<div class="line"><a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a0c4868ee5c5ab673ee54e5dce3be37f1">atan2</a>(<span class="keywordtype">double</span>, <a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a>);</div>
<div class="line"><a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a0c4868ee5c5ab673ee54e5dce3be37f1">atan2</a>(<a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a>, <span class="keywordtype">double</span>);</div>
<div class="line"><a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a0c4868ee5c5ab673ee54e5dce3be37f1">atan2</a>(<a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a>, <a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a>);</div>
</div><!-- fragment --><p>In this case, the return types are a function of both input types. <code>return_type_t</code> is actually written to take any number of input types and compute from them a single scalar return type. The return type is the simplest type that can be constructed from all of the input types. For reverse mode autodiff, this means that if the scalar type of any input argument is a <code>var</code>, then the return type is a var.</p>
<p>A generic signature for <code>real atan2(real, real)</code> is:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S&gt;</div>
<div class="line">return_type_t&lt;T, S&gt; <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a0c4868ee5c5ab673ee54e5dce3be37f1">atan2</a>(T, S);</div>
</div><!-- fragment --><p><code>return_type_t</code> can be used to construct non-scalar return types as well. For the function <code>vector add(vector, vector)</code>, the following generic C++ signature could be used:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S&gt;</div>
<div class="line">Eigen::Matrix&lt;return_type_t&lt;T, S&gt;, Eigen::Dynamic, 1&gt; <a class="code" href="../../d4/d84/namespacestan_1_1math.html#a0c4868ee5c5ab673ee54e5dce3be37f1">atan2</a>(T, S);</div>
</div><!-- fragment --><p>Alternativly, with C++14 one can also delay deducing the return type with <code>auto</code> and the compiler can deduce the return type from the code (which would then internally use <code>return_type_t&lt;T, S&gt;</code>)</p>
<h2><a class="anchor" id="autotoc_md97"></a>
Higher Order Autodiff</h2>
<p>Adding the forward mode autodiff type simply adds more overloads. The forward mode autodiff type itself takes a template argument to represent the types of the value and gradient and allows recursive templating. This technically defines an infinite number of new types, but the ones of interest in Math (and the ones that should be tested are) <code>fvar&lt;double&gt;</code>, <code>fvar&lt;fvar&lt;double&gt;&gt;</code>, <code>fvar&lt;var&gt;</code> and <code>fvar&lt;fvar&lt;var&gt;&gt;</code>. These are useful for computing various high order derivatives. Going back to the <code>real sin(real)</code> function, Math is now expected to implement the following, rather expanded list of functions:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(<span class="keywordtype">double</span>);</div>
<div class="line"><a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a> <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(<a class="code" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">var</a>);</div>
<div class="line">fvar&lt;double&gt; <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(fvar&lt;double&gt;);</div>
<div class="line">fvar&lt;fvar&lt;double&gt;&gt; <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(fvar&lt;fvar&lt;double&gt;&gt;);</div>
<div class="line">fvar&lt;var&gt; <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(fvar&lt;var&gt;);</div>
<div class="line">fvar&lt;fvar&lt;var&gt;&gt; <a class="code" href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a>(fvar&lt;fvar&lt;var&gt;&gt;);</div>
</div><!-- fragment --><p>For the sake of performance, it may be desirable to also define <code>var sin(var)</code>, or similarly <code>fvar&lt;double&gt; sin(fvar&lt;double&gt;)</code> etc.</p>
<p><code>return_type_t</code> is defined similarly as for <code>var</code>. In general, autodiff types should not be mixed, and so the <code>return_type_t</code> does not need to account for various combinations of <code>var</code>, <code>fvar&lt;double&gt;</code>, etc. Sometimes it is useful to mix autodiff types, but it is somewhat uncommon.</p>
<h2><a class="anchor" id="autotoc_md98"></a>
Exceptions</h2>
<p>Math functions are expected to validate inputs and throw exceptions. It should be impossible to cause a segfault by calling a user-facing Math function or trigger an exception that is not handled by Stan itself. This means that argument sizes should be checked to be compatible. For instance, a matrix multiply function would need to check that the first matrix can in fact be multiplied by the second, if this is not so it should throw.</p>
<p>If a scalar argument should be positive, an exception should be thrown if it is not. If a matrix argument should be positive definite, the function should check this before operating on the matrix. This can lead to significant overhead in the checks, but the current library policy is to get informative errors back to the user, which means doing these checks.</p>
<p>Error checks should be done with the functions in <a href="https://github.com/stan-dev/math/tree/develop/stan/math/prim/err">stan/math/prim/err</a> which throw consistently formatted errors.</p>
<h2><a class="anchor" id="autotoc_md99"></a>
Tests</h2>
<p>Tests in Math are written with the Google test framework. At this point there are enough functions in Math that the way to get started is by just copying the tests of a similar Function and editing them to suit the new function. There are two basic sets of functions that every Stan function should have. First, for a function named <code>foo</code>, there should be a file in <code>test/unit/math/prim/fun</code> named <code>foo_test.cpp</code>.</p>
<p>This should include tests that:</p>
<ol type="1">
<li><p class="startli">Check that every exception is throwing in the right way at least once and that all edge cases are handled correctly.</p>
<p class="startli">For instance, if there is a <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#adf85220664649c7ba7c9c893e013c20a" title="Check if the provided sizes match.">check_size_match()</a></code> function, then there should be a test that makes sure that if the sizes don't match, this error gets thrown. It is not necessary to check the error message in the tests, just check that an exception is thrown and the exception type is correct.</p>
</li>
<li><p class="startli">Check that the function returns the expect values for a couple suitable inputs.</p>
<p class="startli">For some functions these checks should be more extensive that others, but there should at least be a two or three even in simple cases.</p>
</li>
</ol>
<p>The <code>prim</code> tests should only have arithmetic types. No autodiff is tested here. The <code>prim</code> tests check that the function handles edge cases correctly and produces the correct output for different function values. The second set of tests should be in <code>stan/math/mix/fun</code> with the same name <code>foo_test.cpp</code>. These tests will be used to test all forms of the autodiff.</p>
<p>The tests in <code>mix/fun</code> should use the <code>expect_ad()</code> function to test all forms of autodiff. <code>expect_ad()</code> takes as its first argument a function to test and then up to three other arguments, all with arithmetic scalar types. For a given function <code>f</code>, and two arguments <code>a</code> and <code>b</code>, <code>expect_ad()</code> tests that:</p>
<ol type="1">
<li>For every combination of <code>a</code> and <code>b</code>, the returned value of <code>f</code> matches the returned value with non-autodiff types.</li>
<li>The finite difference gradients of <code>f</code> match those computed with autodiff.</li>
<li>Any time a <code>f</code> throws with arithmetic arguments, it also throws with autodiff arguments.</li>
</ol>
<h1><a class="anchor" id="autotoc_md100"></a>
Reverse Mode</h1>
<h2><a class="anchor" id="autotoc_md101"></a>
Values</h2>
<p><code>value_of(x)</code> returns the values of the variable <code>x</code>. If <code>x</code> is not an autodiff type, it simply forwards <code>x</code> along. The values of <code>x</code> have the same shape as <code>x</code>. For reverse mode autodiff, values are <code>double</code> variables. For higher order autodiff (<code>fvar&lt;var&gt;</code>, etc.) this is not always the case. See <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a00b8cbdec7c35e7c93b0f47dae3c5498" title="Return the value of the specified variable.">value_of_rec()</a></code> for a different behavior.</p>
<h2><a class="anchor" id="autotoc_md102"></a>
Values and adjoint extensions to Eigen</h2>
<p>The AOS matrix and vector autodiff types come with an extra <code>.val()</code>, <code>.val_op()</code>, <code>.adj()</code>, and <code>.adj_op()</code> member functions.</p>
<p><code>.val()</code> and <code>.val_op()</code> return expressions that evaluate to the values of the autodiff matrix.</p>
<p><code>.adj()</code> and <code>.adj_op()</code> return expressions that evaluate to the adjoints of the autodiff matrix.</p>
<p>The non-<code>_op</code> versions of the functions should be preferred. If the code does not compile (usually an error about const-ness) try the <code>_op</code> versions. This can happen when multiplying the values/adjoints of an AOS autodiff type against other matrices.</p>
<p>It is not safe to use <code>.noalias()</code> with the AOS value/adjoint expressions. In <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a>, <code>.noalias()</code> is similar to the keyworld <a href="https://en.cppreference.com/w/c/language/restrict"><code>restrict</code></a> which assumes that a pointer is unique within a given function. But when performing operations on <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrices of <code>var</code> while using <code>.val()</code> and <code>.adj()</code> on the left and right hand side of an operation, the pointer holding the underlying <code>var</code> types will be used on both sides. Since the pointer is used on both sides it will not be unique in the operation and so using <code>.noalias()</code> will lead to undefined behavior. See the <a href="https://eigen.tuxfamily.org/dox/group__TopicAliasing.html">Aliasing</a> and <a href="https://eigen.tuxfamily.org/dox/TopicWritingEfficientProductExpression.html">Writing Efficient Matrix Product Expressions</a> <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> docs for more info. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacestan_1_1math_html_a3e2385fde5624f0ea3c0d2c60d0568a5"><div class="ttname"><a href="../../d4/d84/namespacestan_1_1math.html#a3e2385fde5624f0ea3c0d2c60d0568a5">stan::math::real</a></div><div class="ttdeci">T real(const std::complex&lt; T &gt; &amp;z)</div><div class="ttdoc">Return the real component of the complex argument.</div><div class="ttdef"><b>Definition:</b> <a href="../../d8/d23/real_8hpp_source.html#l00018">real.hpp:18</a></div></div>
<div class="ttc" id="anamespacestan_1_1math_html_a0c4868ee5c5ab673ee54e5dce3be37f1"><div class="ttname"><a href="../../d4/d84/namespacestan_1_1math.html#a0c4868ee5c5ab673ee54e5dce3be37f1">stan::math::atan2</a></div><div class="ttdeci">fvar&lt; T &gt; atan2(const fvar&lt; T &gt; &amp;x1, const fvar&lt; T &gt; &amp;x2)</div><div class="ttdef"><b>Definition:</b> <a href="../../d9/de3/fwd_2fun_2atan2_8hpp_source.html#l00013">atan2.hpp:13</a></div></div>
<div class="ttc" id="anamespacestan_1_1math_html_ac37be6da87f3444ae2f7a00f6fee2983"><div class="ttname"><a href="../../d4/d84/namespacestan_1_1math.html#ac37be6da87f3444ae2f7a00f6fee2983">stan::math::dot_self</a></div><div class="ttdeci">auto dot_self(const T &amp;a)</div><div class="ttdoc">Returns squared norm of a vector or matrix.</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d35/opencl_2prim_2dot__self_8hpp_source.html#l00021">dot_self.hpp:21</a></div></div>
<div class="ttc" id="agroup__opencl__kernel__generator_html_ga797d34ad217be5a5367c83b2babc4a19"><div class="ttname"><a href="../../d2/d3c/group__opencl__kernel__generator.html#ga797d34ad217be5a5367c83b2babc4a19">stan::math::add</a></div><div class="ttdeci">addition_&lt; as_operation_cl_t&lt; T_a &gt;, as_operation_cl_t&lt; T_b &gt; &gt; add(T_a &amp;&amp;a, T_b &amp;&amp;b)</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d76/binary__operation_8hpp_source.html#l00189">binary_operation.hpp:189</a></div></div>
<div class="ttc" id="anamespacestan_1_1math_html_aff3f2dd84567a0566cfdd7eb10e13607"><div class="ttname"><a href="../../d4/d84/namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">stan::math::sin</a></div><div class="ttdeci">fvar&lt; T &gt; sin(const fvar&lt; T &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/df5/fwd_2fun_2sin_8hpp_source.html#l00014">sin.hpp:14</a></div></div>
<div class="ttc" id="anamespacestan_1_1math_html_a713cc9385182249d547389028a723a1a"><div class="ttname"><a href="../../d4/d84/namespacestan_1_1math.html#a713cc9385182249d547389028a723a1a">stan::math::to_arena</a></div><div class="ttdeci">arena_t&lt; T &gt; to_arena(const T &amp;a)</div><div class="ttdoc">Converts given argument into a type that either has any dynamic allocation on AD stack or schedules i...</div><div class="ttdef"><b>Definition:</b> <a href="../../dc/d2c/opencl_2rev_2to__arena_8hpp_source.html#l00025">to_arena.hpp:25</a></div></div>
<div class="ttc" id="anamespacestan_1_1math_html_adbd7c862016910e0217ad1893736bcce"><div class="ttname"><a href="../../d4/d84/namespacestan_1_1math.html#adbd7c862016910e0217ad1893736bcce">stan::math::apply</a></div><div class="ttdeci">constexpr decltype(auto) apply(F &amp;&amp;f, Tuple &amp;&amp;t)</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d4c/apply_8hpp_source.html#l00043">apply.hpp:43</a></div></div>
<div class="ttc" id="anamespacestan_1_1math_html_a7953d993880449ed4d741e6e891d2f7b"><div class="ttname"><a href="../../d4/d84/namespacestan_1_1math.html#a7953d993880449ed4d741e6e891d2f7b">stan::math::sum</a></div><div class="ttdeci">fvar&lt; T &gt; sum(const std::vector&lt; fvar&lt; T &gt;&gt; &amp;m)</div><div class="ttdoc">Return the sum of the entries of the specified standard vector.</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/df6/fwd_2fun_2sum_8hpp_source.html#l00022">sum.hpp:22</a></div></div>
<div class="ttc" id="anamespacestan_1_1math_html_a4dc059c1f55cae403aba50db7866e80e"><div class="ttname"><a href="../../d4/d84/namespacestan_1_1math.html#a4dc059c1f55cae403aba50db7866e80e">stan::math::reverse_pass_callback</a></div><div class="ttdeci">void reverse_pass_callback(F &amp;&amp;functor)</div><div class="ttdoc">Puts a callback on the autodiff stack to be called in reverse pass.</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d2a/reverse__pass__callback_8hpp_source.html#l00038">reverse_pass_callback.hpp:38</a></div></div>
<div class="ttc" id="anamespacestan_1_1math_html_ab12dd8270b3ffc0ee066d306b240f4bb"><div class="ttname"><a href="../../d4/d84/namespacestan_1_1math.html#ab12dd8270b3ffc0ee066d306b240f4bb">stan::math::make_callback_var</a></div><div class="ttdeci">var_value&lt; plain_type_t&lt; T &gt; &gt; make_callback_var(T &amp;&amp;value, F &amp;&amp;functor)</div><div class="ttdoc">Creates a new var initialized with a callback_vari with a given value and reverse-pass callback funct...</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/d8e/callback__vari_8hpp_source.html#l00061">callback_vari.hpp:61</a></div></div>
<div class="ttc" id="anamespacestan_1_1math_html_a68817034db6ea04cda51c87bc86329a6"><div class="ttname"><a href="../../d4/d84/namespacestan_1_1math.html#a68817034db6ea04cda51c87bc86329a6">stan::math::multiply</a></div><div class="ttdeci">auto multiply(const Mat1 &amp;m1, const Mat2 &amp;m2)</div><div class="ttdoc">Return the product of the specified matrices.</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d47/fwd_2fun_2multiply_8hpp_source.html#l00018">multiply.hpp:18</a></div></div>
<div class="ttc" id="anamespacestan_1_1math_html_abf1141ed12907bf4b7c268faa6126762"><div class="ttname"><a href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a></div><div class="ttdeci">var_value&lt; double &gt; var</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/da7/var_8hpp_source.html#l01100">var.hpp:1100</a></div></div>
<div class="ttc" id="anamespacestan_1_1math_html_a3145f3467ad20649633bbf9842ddf909"><div class="ttname"><a href="../../d4/d84/namespacestan_1_1math.html#a3145f3467ad20649633bbf9842ddf909">stan::math::to_ref</a></div><div class="ttdeci">ref_type_t&lt; T &amp;&amp; &gt; to_ref(T &amp;&amp;a)</div><div class="ttdoc">This evaluates expensive Eigen expressions.</div><div class="ttdef"><b>Definition:</b> <a href="../../de/ddd/to__ref_8hpp_source.html#l00017">to_ref.hpp:17</a></div></div>

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
